<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/weightedAdjacencyMatrix.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/weightedAdjacencyMatrix.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*=============== Weighted Adjacency Matrix Graph ====================*/


&quot;use strict&quot;;

class WeightedAdjacencyMatrix {

    /**
     * Creates a color coded adjacency matrix contained in a WeightedAdjMat object
     * @class
     * @constructor
     * @param {String} divID - the id of the div that contains the graph, e.g &quot;#id&quot;
     * @param {Object} matrixConfiguration - The configurations of the adjacency matrix
     */
    constructor(divID, matrixConfiguration) {
        /**
         * @memberof WeightedAdjMat
         * @type {Object}
         * @property {Object} transform - The transform property can be used to position and scale the WeightedAdjMat object
         * @property {Object} matrix - The matix property can be used to position, scale and color the matrix
         * @property {Object} label - The label property can be used to color and scale the matrix labels
         * @property {Object} text - The text property can be used to color and scale the matrix cell weight
         * @property {Object} background - The background property can be used to change the color of the background
         */
        let defaultConfig = {
            transform: {
                x: 0,
                y: 0,
                width: window.innerWidth,
                height: window.innerHeight
            },
            matrix: {
                x: 0.2,
                y: 0.2,
                dim: 0.6, // dimenion relative to the WeightedAdjMat that contains the matrix
                spacing: 1, // spacing between each cell
                color: &quot;#63c59b&quot;
            },
            label: {
                color: &quot;#52bf90&quot;,
                size: 0.3, // text size = size * circle radius
                anchor: &quot;middle&quot;,
                alignment: &quot;middle&quot;
            },
            weight: {
                color: &quot;white&quot;,
                size: 0.6, // text size = size * circle radius
                anchor: &quot;middle&quot;,
                alignment: &quot;middle&quot;
            },
            background: {
                color: &quot;#ecf6f2&quot;
            }
        };

        this.config = matrixConfiguration || defaultConfig;

        this._divID = divID;

        this._adjMatData = []; // Contains the matrix cell data and cell label data

        this._rowLabel = []; // Contains the row labels in string. e.g[&quot;square&quot;, &quot;circle&quot;]

        this._colLabel = []; // Contains the column labels in string. e.g[&quot;square&quot;, &quot;circle&quot;]

        this._svg = d3.select(this._divID)
            .append(&apos;svg&apos;)
            .attr(&quot;class&quot;, &quot;weightedAdjMat&quot;)
            .attr(&apos;width&apos;, this.config.transform.width)
            .attr(&apos;height&apos;, this.config.transform.height)
            .append(&apos;g&apos;)
            .attr(&quot;transform&quot;, &quot;translate(&quot; + this.config.transform.x + &quot;,&quot; + this.config.transform.y + &quot;)&quot;);

        // Create the background wrapper for color theme
        this._svg.append(&quot;rect&quot;)
            .attr(&quot;class&quot;, &quot;background&quot;)
            .attr(&quot;width&quot;, this.config.transform.width)
            .attr(&quot;height&quot;, this.config.transform.height)
            .style(&quot;fill&quot;, this.config.background.color);
    }


    /**
     * Darkens or lightens hex color value
     * @function _shadeColor
     * @param {String} colorHex - a hex color string. ie. &quot;#63c59b&quot;
     * @param {Number} percentage - shading ranges form -100(dark) to +100(light)
     */
    _shadeColor(colorHex, percent) {

        let R = parseInt(colorHex.substring(1, 3), 16);
        let G = parseInt(colorHex.substring(3, 5), 16);
        let B = parseInt(colorHex.substring(5, 7), 16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = (R &lt; 255) ? R : 255;
        G = (G &lt; 255) ? G : 255;
        B = (B &lt; 255) ? B : 255;

        let RR = ((R.toString(16).length === 1) ? &quot;0&quot; + R.toString(16) : R.toString(16));
        let GG = ((G.toString(16).length === 1) ? &quot;0&quot; + G.toString(16) : G.toString(16));
        let BB = ((B.toString(16).length === 1) ? &quot;0&quot; + B.toString(16) : B.toString(16));

        return &quot;#&quot; + RR + GG + BB;
    }


    /** 
     * Draws the adjancy matrix based on the property of each cell
     * @function redrawMatrix
     */
    redrawMatrix() {
        /* Draw the adjancy matrix */

        d3.selectAll(this._divID + &quot; g .cell&quot;).remove();
        d3.selectAll(this._divID + &quot; g .label&quot;).remove();

        // Each cell group holds 
        let cell = this._svg.selectAll(&apos;g&apos;)
            .data(this._adjMatData).enter()
            .append(&quot;g&quot;)
            .attr(&quot;class&quot;, &quot;cell&quot;)
            .attr(&quot;transform&quot;, d =&gt; &quot;translate(&quot; + d.x + &quot;,&quot; + d.y + &quot;)&quot;);

        // Each rect is a matrix cell
        cell.append(&quot;rect&quot;)
            .attr(&quot;transform&quot;, &quot;translate(&quot; + -this.config.matrix.cellDim / 2 + &quot;,&quot; + -this.config.matrix.cellDim / 2 + &quot;)&quot;)
            .attr(&apos;width&apos;, this.config.matrix.cellDim)
            .attr(&apos;height&apos;, this.config.matrix.cellDim)
            .attr(&apos;fill&apos;, d =&gt; {
                // Add color to the cell matrix
                if (d.type === &quot;cellData&quot;) {
                    return this._shadeColor(this.config.matrix.color, -d.colorWeight * 5);
                }
                if (d.type === &quot;cellLabel&quot;) {
                    return this.config.background.color;
                }
            });


        // Add cell weight text
        cell.append(&quot;text&quot;)
            .attr(&quot;font-size&quot;, this.config.matrix.cellDim * this.config.weight.size)
            .attr(&quot;text-anchor&quot;, this.config.weight.anchor)
            .attr(&quot;alignment-baseline&quot;, this.config.weight.alignment)
            .attr(&quot;fill&quot;, this.config.weight.color)
            .text(d =&gt; {
                if (d.type === &quot;cellData&quot;) {
                    return d.weight;
                }
            });

        // Add cell label text
        cell.append(&quot;text&quot;)
            .attr(&quot;font-size&quot;, this.config.matrix.cellDim * this.config.label.size)
            .attr(&quot;text-anchor&quot;, this.config.label.anchor)
            .attr(&quot;alignment-baseline&quot;, this.config.label.alignment)
            .attr(&quot;fill&quot;, this.config.label.color)
            .text(d =&gt; {
                if (d.type === &quot;cellLabel&quot;) {
                    return d.label;
                }
            });
    }

    /** 
     * Creates an adjacency matrix based on the row and column labels
     * @function WeightedAdjMat.createMatrix
     * @param {Array} rowLab - labels that represent the row of the matrix
     * @param {Array} colLab - labels that represent the column of the matrix
     */
    createMatrix(rowLab, colLab) {

        this._rowLabel = rowLab; // Update the labels
        this._colLabel = colLab; // Update the labels

        // Calculate the dimension of each block and other matrix config properties
        this.config.matrix.cellDim = this.config.matrix.cellDim * Array.min([this.config.transform.width, this.config.transform.height]) / Array.max([this._rowLabel.length, this._colLabel.length]);
        this.config.matrix.cellSpacing *= this.config.matrix.cellDim / 10;
        this.config.matrix.x *= this.config.transform.width;
        this.config.matrix.y *= this.config.transform.height;

        // Populate adjacency matrix data
        let id = 0;
        let x;
        let y;
        for (let i = 0; i &lt; this._rowLabel.length; i++) {
            for (let j = 0; j &lt; this._colLabel.length; j++) {
                x = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (j + 1 / 2) + this.config.matrix.x;
                y = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (i + 1 / 2) + this.config.matrix.y;
                this._adjMatData.push({
                    type: &quot;cellData&quot;,
                    id: id,
                    x: x,
                    y: y,
                    weight: 0,
                    colorWeight: 0
                });
                id++;
            }
        }

        // Add column labels to the adjacent matrix.
        for (let i = 0; i &lt; this._colLabel.length; i++) {
            // Add column labels
            x = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (i + 1 / 2) + this.config.matrix.x;
            y = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (-1 / 2) + this.config.matrix.y;
            this._adjMatData.push({
                type: &quot;cellLabel&quot;,
                label: this._colLabel[i],
                x: x,
                y: y,
            });
        }

        // Add row labels to the adjacent matrix.
        for (let i = 0; i &lt; this._rowLabel.length; i++) {
            // Add row labels
            x = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (-1 / 2) + this.config.matrix.x;
            y = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (i + 1 / 2) + this.config.matrix.y;
            this._adjMatData.push({
                type: &quot;cellLabel&quot;,
                label: this._rowLabel[i],
                x: x,
                y: y,
            });
        }

        this.redrawMatrix();
    }


    /** 
     * Increases the matix cell weight by label pair.
     * @function WeightedAdjMat.increaseCellWeight
     * @param {Array} cell - the cell to increase weight is represented by a coordinate pair using labels, ie. cell = (rowLabel, colLabel)
     * @param {Integer} weight - used to increase the weight of the cell
     */
    increaseCellWeight(cell, weight) {
        let row = this._rowLabel.indexOf(cell[0]);
        let col = this._colLabel.indexOf(cell[1]);

        if (row &lt; 0 || col &lt; 0) throw new Error(&quot;updateMatrix(cell): the element updated does not exist in the adjacency matrix.&quot;);

        let elementIndex = row * this._colLabel.length + col;
        this._adjMatData[elementIndex].weight += weight;
    }


    /** 
     * Increases the matix cell color weight and darkens the color by label pair.
     * @function WeightedAdjMat.increaseCellColor
     * @param {Array} cell - the cell to increase weight is represented by a coordinate pair using labels, ie. cell = (rowLabel, colLabel)
     * @param {Integer} weight - used to increase the color weight of the cell
     */
    increaseCellColor(cell, colorWeight) {
        let row = this._rowLabel.indexOf(cell[0]);
        let col = this._colLabel.indexOf(cell[1]);

        if (row &lt; 0 || col &lt; 0) throw new Error(&quot;updateMatrix(cell): the element updated does not exist in the adjacency matrix.&quot;);

        let elementIndex = row * this._colLabel.length + col;
        this._adjMatData[elementIndex].colorWeight += colorWeight;
    }


    /** 
     * Increases the matix column color weight and darkens the color
     * @function WeightedAdjMat.increaseColumnColor
     * @param {Array} colLabel - the label of the column to increase weight is represented by a label in string
     * @param {Integer} weight - used to increase the color weight of the cell
     */
    increaseColumnColor(colLabel, colorWeight) {
        let col = this._colLabel.indexOf(colLabel);

        if (col &lt; 0) throw new Error(&quot;increaseColumnColor: the column updated does not exist in the adjacency matrix.&quot;);

        for (let row = 0; row &lt; this._rowLabel.length; row++) {
            let elementIndex = row * this._colLabel.length + col;
            this._adjMatData[elementIndex].colorWeight += colorWeight;
        }
    }


    /** 
     * Reset the matix cell weight
     * @function WeightedAdjMat.resetMatrixWeight
     */
    resetMatrixWeight() {
        /* Reset each matrix cell weight to 0 */
        for (let i = 0; i &lt; this._adjMatData.length; i++) {
            if (this._adjMatData[i].type === &quot;cellData&quot;) {
                this._adjMatData[i].weight = 0;
            }
        }
    }

    /** 
     * Reset the matix cell color weight and updates color based on the weight
     * @function WeightedAdjMat.resetMatrixColorWeight
     */
    resetMatrixColorWeight() {
        /* Reset each matrix cell weight to 0 */
        for (let i = 0; i &lt; this._adjMatData.length; i++) {
            if (this._adjMatData[i].type === &quot;cellData&quot;) {
                this._adjMatData[i].colorWeight = 0;
            }
        }
    }

    /** 
     * Get the matix cell weight by cell pair = (i, j)
     * @function WeightedAdjMat.getCellWeight
     * @param {Array} cell - the cell to increase weight is represented by a coordinate pair, ie. cell = (i, j)
     * @return {Integer} cell weight
     */
    getCellWeight(cell) {
        let i = cell[0];
        let j = cell[1];

        if (i &gt; this._colLabel.length || j &gt; this._rowLabel.length || i &lt; 0 || j &lt; 0) throw new Error(&quot;getCellWeight(cell): the element to get does not exist in the adjacency matrix.&quot;);

        let elementIndex = i + j * this._colLabel.length;
        return this._adjMatData[elementIndex].weight;
    }


    getMatrix1D() {
        // Returns the adjacency matrix as a 1D array
        let matrix1D = [];
        for (let i = 0; i &lt; this._adjMatData.length; i++) {
            if (this._adjMatData[i].type == &quot;cellData&quot;) {
                matrix1D.push(this._adjMatData[i].weight);
            }
        }
        return matrix1D;
    }

    getMatrix2D() {
        // Returns the adjacency matrix as a 2D array,
        // matrix = [col1, col2, col3];
        let matrix1D = this.getMatrix1D();
    }


    //    resetRowLabel(row) {
    //        this._rowLabel = row;
    //    }
    //
    //    resetColLabel(col) {
    //        this._colLabel = col;
    //    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
