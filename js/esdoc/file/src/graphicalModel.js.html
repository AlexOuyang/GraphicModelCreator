<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/graphicalModel.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/graphicalModel.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*=============== Probability Graphic Model ====================*/

&quot;use strict&quot;;

/**
 * This is the regulra probability Graphical Model that supports auto play loops and zoom in ability. It is the basis of ListenerObserverPGM.
 */

class GraphicalModel {

    /**
     * This is GraphicalModel constructor description.
     * @param {object} - graphConfiguration is a configuration object for configuring the properties of this pgm, it can be obtained via Config.getPgmConfig().
     * @param {string} - divID is the id of the html tag that contains this pgm, it is of the form &apos;#id_name&apos;.
     */
    constructor(graphConfiguration, divID) {

        this._weightedAdjMat = null; // holds the adjacency matrix chart 

        let defaultConfig = {
            transform: {
                x: 0,
                y: 0,
                width: window.innerWidth,
                height: window.innerHeight - 80
            },
            vertex: {
                radius: 0.35,
                defaultStyle: {
                    backgroundColor: &quot;#52bf90&quot;,
                    outlineColor: &quot;#317256&quot;
                },
                visited: {
                    visitedColor: &quot;#1d4433&quot;,
                    outlineColor: &quot;#1d4433&quot;
                }
            },
            edge: {
                baseWidth: 0, // base width offset = baseWidth * circle radius
                width: 0.5, // edge width = width * circle radius
                defaultColor: &quot;#b6ddcc&quot;,
                visitedColor: &quot;#1d4433&quot;,
                timeInterval: 600 // timeInterval to complete highlighting on edge is in millisecond
            },
            text: {
                color: &quot;white&quot;,
                size: 0.5, // text size = size * circle radius
                anchor: &quot;middle&quot;,
                alignment: &quot;middle&quot;

            },
            background: {
                grid: true,
                color: &quot;#ecf6f2&quot;
            },
            autoPlay: {
                on: false, // true when user clicks on the play button and the graph cycles, else false
                button: {
                    dim: 1, // size of the play button
                    color: &quot;#74cba6&quot;
                },
                timeIntervalBetweenCycle: 800
            },
            autoPlayable: true, // If autoPlayable, creates the autoplay button    
            cyclingSpeedControllable: true, // if cyclingSpeedControllable, create speed button
            zoomable: true,
        };

        this.config = graphConfiguration || defaultConfig;

        this.graphData = {
            clusterMat: [], // data specifies the nodes in each layer
            data: [] // data binds to the graph
        };

        this._directedPath = []; // _directedPath is a list of visited nodes&apos; ID

        this._canClick = true; // Used to keep user from clicking when the graph is traversing

        this.speakerLayerProbabilityDistribution = []; //  an array of probability given to each node in the speaker layer, probabilityDistribution=[] if uniform distribution


        let pgm = this;

        this.divID = divID;

        // Click on the node in the speaker layer to draw visited path
        this.onClick = d3.behavior.drag()
            .origin(d =&gt; d)
            .on(&quot;dragstart&quot;, function(d) {
                // Check if the clicked node is in the first layer
                // which are the num of nodes in first layer of clusterMat
                // Only allow user to click the node if autoplay is off
                if (pgm._canClick &amp;&amp; !pgm.config.autoPlayable) {
                    d3.event.sourceEvent.stopPropagation();
                    d3.select(this).classed(&quot;dragging&quot;, true);
                    pgm._triggerSpeakerNode(this.id);
                }
            });

        this.svg = d3.select(divID).append(&quot;svg&quot;)
            .attr(&quot;class&quot;, &quot;graph&quot;)
            .attr(&quot;width&quot;, this.config.transform.width)
            .attr(&quot;height&quot;, this.config.transform.height)
            .append(&quot;g&quot;)
            .attr(&quot;transform&quot;, &quot;translate(&quot; + this.config.transform.x + &quot;,&quot; + this.config.transform.y + &quot;)&quot;);

        // Set up the background rect wrapper
        this.rect = this.svg.append(&quot;rect&quot;)
            .attr(&quot;class&quot;, &quot;background&quot;)
            .attr(&quot;width&quot;, this.config.transform.width)
            .attr(&quot;height&quot;, this.config.transform.height)
            .style(&quot;fill&quot;, this.config.background.color)
            .style(&quot;pointer-events&quot;, &quot;all&quot;)
            .on(&quot;click&quot;, d =&gt; {
                pgm._backgroundOnClick();
            });

        this.container = this.svg.append(&quot;g&quot;);

        // Specify the function for generating path data   
        // &quot;linear&quot; for piecewise linear segments
        // Creating path using data in pathinfo and path data generator
        // Used in _drawEdges() and _drawVisitedPath();
        this.line = d3.svg.line()
            .x(d =&gt; d.x)
            .y(d =&gt; d.y)
            .interpolate(&quot;linear&quot;);

        this.vertices = null; // D3 object, initiated in drawVertices()


        // Zoom behavior
        this.zoom = d3.behavior.zoom().scaleExtent([1, 10])
            .on(&quot;zoom&quot;, () =&gt; {
                this.container.attr(
                    &quot;transform&quot;,
                    &quot;translate(&quot; + d3.event.translate + &quot;)scale(&quot; + d3.event.scale + &quot;)&quot;
                );
            });

        // Zoom behavior
        if (this.config.zoomable) {
            this.svg.call(this.zoom);
        }

    }

    _backgroundOnClickToResetAdjMatrix() {
        if (this._weightedAdjMat) {
            this._weightedAdjMat.resetMatrixWeight();
            this._weightedAdjMat.resetMatrixColorWeight();
            this._weightedAdjMat.redrawMatrix();
        }
    }

    _backgroundOnClick() {
        if (!this.config.autoPlayable) {
            if (this._canClick &amp;&amp; !this.config.autoPlay.on) {
                this._clearVisitedPath();
                // Do not allow user to click until visited path highlighting is finished
                this._canClick = false;
                setTimeout(() =&gt; this._canClick = true, this.config.edge.timeInterval * (this._directedPath.length - 1));

                // click on background to reset adjacency matrix
                this._backgroundOnClickToResetAdjMatrix();
            }
        }
    }

    _dataScreening(data) {
        /* Verifies if each vertex&apos;s id matches its position in the array 
        and the weights of all adjacent vertices sum to 1; */

        if (data.length &lt;= 1) {
            throw new Error(&quot;input graph data is empty&quot;);
        }

        let weightSum = 0;
        for (let vertexIdx = 0; vertexIdx &lt; data.length; vertexIdx++) {
            if (data[vertexIdx].id !== vertexIdx) {
                throw new Error(&quot;Vertex&apos;s id must match its position index in the list of vertices. The &quot; + vertexIdx + &quot; th element in the list does not match its position index&quot;);
            }
            let allEdgeZero = true;
            let adjVertices = data[vertexIdx].edgeWeights;
            if (adjVertices) {
                // Check if all edges have weight 0

                for (let i = 0; i &lt; adjVertices.length; i++) {
                    weightSum += adjVertices[i].weight;
                    if (adjVertices[i].weight !== 0) allEdgeZero = false;
                }

                if (weightSum !== 1.0 &amp;&amp; allEdgeZero === false) {
                    throw new Error(&quot;The sum of a vertex&apos;s adjacent edge&apos;s weight must be 1 or all edges have a weight of 0. &quot; + &quot;The &quot; + vertexIdx + &quot;th vertex is invalid.&quot;);
                }
            }
            weightSum = 0;
        }
    }


    _createEdgesInGraphData(data) {
        // Takes in the graph data, modifies the data by adding a list of edges into the data and add to self   
        if (data.length &lt;= 1) {
            throw new Error(&quot;input graph data is empty&quot;);
        }

        // Go through each vertex in data and add &apos;edges&apos; attribute to each vertex
        for (let vertexIdx = 0; vertexIdx &lt; data.length; vertexIdx++) {
            let currentVertex = data[vertexIdx];
            if (!currentVertex.edgeWeights) {
                currentVertex.edges = null;
            } else {
                currentVertex.edges = [];
                for (let adjVertexIdx = 0; adjVertexIdx &lt; currentVertex.edgeWeights.length; adjVertexIdx++) {
                    let targetVertexId = currentVertex.edgeWeights[adjVertexIdx].id;
                    let targetVertexWeight = currentVertex.edgeWeights[adjVertexIdx].weight;

                    let edge = {
                        edgeWeight: targetVertexWeight,
                        edgeNodes: [currentVertex, data[targetVertexId]]
                    };

                    currentVertex.edges.push(edge);
                }
            }
        }
    }

    _chooseRandomAdjVertexFromSpeakerLayer() {
        /*
        Choose a random adjacent vertex in the speaker layer based on the edge weights 
        */
        let weightDistribution = [0]; // weightDistribution is a distribution from 0 to 1, ex: [0, 0.4, 1]
        let weight = 0;
        for (let i = 0; i &lt; this.speakerLayerProbabilityDistribution.length; i++) {
            weight += this.speakerLayerProbabilityDistribution[i];
            weightDistribution.push(weight);
        }

        let randomPick = Math.random();
        console.log(&quot;weight distribution corresponding to the speaker layer: (&quot; + weightDistribution + &quot;) random pick: &quot; + randomPick);
        for (let i = 0; i &lt; weightDistribution.length - 1; i++) {
            if (randomPick &gt;= weightDistribution[i] &amp;&amp; randomPick &lt;= weightDistribution[i + 1]) {
                return this.graphData.data[i].id;
            }
        }
    }

    _chooseRandomAdjVertex(vertex) {
        /*
        Takes in a vertex and choose a random adjacent vertex in the next layer based on the edge weights 
        */
        let weightDistribution = [0]; // weightDistribution is a distribution from 0 to 1, ex: [0, 0.4, 1]
        let weight = 0;
        for (let i = 0; i &lt; vertex.edgeWeights.length; i++) {
            weight += vertex.edgeWeights[i].weight;
            weightDistribution.push(weight);
        }

        let randomPick = Math.random();
        console.log(&quot;weight distribution corresponding to adjacent vertices in the next layer: (&quot; + weightDistribution + &quot;) random pick: &quot; + randomPick);

        // if the sum of distribution is 0 then return -1
        let distributionSum = weightDistribution.reduce(function(a, b) {
            return a + b;
        }, 0);
        if (distributionSum === 0) {
            return -1;
        }

        for (let i = 0; i &lt; weightDistribution.length - 1; i++) {
            if (randomPick &gt;= weightDistribution[i] &amp;&amp; randomPick &lt;= weightDistribution[i + 1]) {
                return vertex.edgeWeights[i].id;
            }
        }
    }

    _traverseGraph(vertexId, data) {
        /* 
        Takes in the id of a node and traverse trough the graph to connect 
        impacted nodes and returns the id of the visited node
        */

        let visitedNodes = [vertexId];
        let node = data[vertexId];

        while (node !== undefined &amp;&amp; node.edgeWeights !== undefined) {
            console.log(&quot;Current Vertex: &quot; + vertexId);
            vertexId = this._chooseRandomAdjVertex(node);
            // if (vertexId &lt; 0) break;
            console.log(&quot;Vextex chosen: &quot; + vertexId);
            console.log(&quot;--------&quot;);
            node = data[vertexId];
            visitedNodes.push(vertexId);
        }

        this._directedPath = visitedNodes;
    }



    _drawGrid() {
        /* Draws the axis in the background */

        this.container.append(&quot;g&quot;)
            .attr(&quot;class&quot;, &quot;x axis&quot;)
            .selectAll(&quot;line&quot;)
            .data(d3.range(0, this.config.transform.width, 10))
            .enter().append(&quot;line&quot;)
            .attr(&quot;x1&quot;, d =&gt; d)
            .attr(&quot;y1&quot;, 0)
            .attr(&quot;x2&quot;, d =&gt; d)
            .attr(&quot;y2&quot;, this.config.transform.height);

        this.container.append(&quot;g&quot;)
            .attr(&quot;class&quot;, &quot;y axis&quot;)
            .selectAll(&quot;line&quot;)
            .data(d3.range(0, this.config.transform.height, 10))
            .enter().append(&quot;line&quot;)
            .attr(&quot;x1&quot;, 0)
            .attr(&quot;y1&quot;, d =&gt; d)
            .attr(&quot;x2&quot;, this.config.transform.width)
            .attr(&quot;y2&quot;, d =&gt; d);
    }


    _drawText() {
        /* Add a text element to the previously added g element. */
        this.vertices.append(&quot;text&quot;)
            .attr(&quot;font-size&quot;, d =&gt; d.r * this.config.text.size)
            .attr(&quot;text-anchor&quot;, this.config.text.anchor)
            .attr(&quot;alignment-baseline&quot;, this.config.text.alignment)
            .attr(&quot;fill&quot;, this.config.text.color)
            .text(d =&gt; {
                if (d.label) {
                    return d.label;
                } else {
                    return d.id;
                }
            });
    }

    _drawVertices(data) {
        /* clear vertices then redraw all the vertices in the grpah */

        d3.selectAll(this.divID + &quot; g .vertex&quot;).remove();

        // Create vertex groups, each group contains a cicle and a text
        this.vertices = this.container.append(&quot;g&quot;)
            .attr(&quot;class&quot;, &quot;vertex&quot;)
            .selectAll(&quot;circle&quot;)
            .data(data).enter()
            .append(&quot;g&quot;)
            .attr(&quot;id&quot;, d =&gt; d.id)
            .attr(&quot;transform&quot;, d =&gt; &quot;translate(&quot; + d.x + &quot;,&quot; + d.y + &quot;)&quot;)
            .call(this.onClick);

        this.vertices.append(&quot;circle&quot;)
            .attr(&quot;r&quot;, d =&gt; d.r);

        this._drawText();
    }

    _drawEdges(data) {
        /* Draw all edges and high light visited color */

        // clear edges then redraw all the edges in the graph 
        d3.selectAll(this.divID + &quot; path&quot;).remove();

        // Draw all edges based on weight in default color
        for (let vertexIdx = 0; vertexIdx &lt; data.length; vertexIdx++) {
            // Iterate through each nodes in data
            let currentVertex = data[vertexIdx];
            if (currentVertex.edges) {
                for (let edgeIdx = 0; edgeIdx &lt; currentVertex.edges.length; edgeIdx++) {
                    // Iterate through each edge in the current node
                    let edgeNodes = currentVertex.edges[edgeIdx].edgeNodes;
                    let edgeWeight = currentVertex.edges[edgeIdx].edgeWeight * this.config.edge.width;
                    this.container.append(&quot;svg:path&quot;)
                        .attr(&quot;d&quot;, this.line(edgeNodes))
                        .attr(&quot;stroke-width&quot;, edgeWeight + this.config.edge.baseWidth)
                        .style(&quot;stroke&quot;, this.config.edge.defaultColor)
                        .style(&quot;fill&quot;, &quot;none&quot;);
                }
            }
        }

    }

    /* EdgeNodes contains a pair of nodes (e.g. [node1, node2]) which are two ends of an edge, lengthMultiplier is used to determine the magnitude of the edge

    @returns a highlightedEdge objects that contains the nodes information and the length information
     */
    _drawHighlightedEdge(edgeNodes, lengthMultiplier) {
        let x0 = edgeNodes[0].x,
            y0 = edgeNodes[0].y,
            r0 = edgeNodes[0].r,
            x1 = edgeNodes[1].x,
            y1 = edgeNodes[1].y,
            r1 = edgeNodes[1].r,
            distX = x1 - x0,
            distY = y0 - y1,
            dist = Math.sqrt(distX * distX + distY * distY),
            ratio0 = r0 / (lengthMultiplier * dist),
            ratio1 = r1 / (lengthMultiplier * dist),

            // tempEdges for highlighting the visited edges
            highlightedEdgeNodes = [{
                x: x0 + distX * ratio0,
                y: y0 - distY * ratio0
            }, {
                x: x1 - distX * ratio1,
                y: y1 + distY * ratio1
            }];


        let highlightedEdge = {
            nodes: highlightedEdgeNodes,
            length: dist
        };

        return highlightedEdge;
    }

    _drawVisitedPath(data) {
        /* Draw visited edges based on weight in highlighted color */

        for (let vertexIdx = 0; vertexIdx &lt; this._directedPath.length; vertexIdx++) {

            // check if there&apos;s -1 in _directedPath, if yes, do not draw the path and trigger a new speaker
            if (this._directedPath[vertexIdx] &lt; 0) {

                // Draw the first vertex when the path start highlighting
                this.vertices.append(&quot;circle&quot;)
                    .attr(&quot;class&quot;, d =&gt; {
                        // if the node is in the path then draw it in a different color
                        if (this._directedPath[0] === d.id) {
                            return &quot;visitedVertex&quot;;
                        }
                    })
                    .attr(&quot;r&quot;, d =&gt; d.r);

                // Add a text element to the previously added g element.
                this._drawText();

                setTimeout(() =&gt; {

                    // If autoplay is on, then restart the cycle after [timeIntervalBetweenCycle] milliseconds
                    if (this.config.autoPlay.on) {
                        console.log(&quot;Auto play is on!&quot;);
                        setTimeout(() =&gt; {
                            this._triggerSpeakerNodeAutoPlay();
                        }, this.config.autoPlay.timeIntervalBetweenCycle);
                    }

                }, this.config.edge.timeInterval);
            } else {

                // If there&apos;s no -1 in directed path
                // Iterate through the list of ID in _directedPath 
                let currentVertex = data[this._directedPath[vertexIdx]];
                if (currentVertex.edges) {
                    for (let edgeIdx = 0; edgeIdx &lt; currentVertex.edges.length; edgeIdx++) {
                        let edgeNodes = currentVertex.edges[edgeIdx].edgeNodes;
                        let edgeWeight = currentVertex.edges[edgeIdx].edgeWeight * this.config.edge.width;
                        // If the edge is in the _directedPath then draw different color
                        if (this._directedPath.indexOf(edgeNodes[0].id) &gt; -1 &amp;&amp; this._directedPath.indexOf(edgeNodes[1].id) &gt; -1) {

                            // Create two new points to draw a shorter edge so the new 
                            // edge will not cover the id in the node
                            let highlightingEdgeLengthMultiplier = 1.1; // Used to increase the length of the highlighted edge on both ends;
                            let highlightedEdge = this._drawHighlightedEdge(edgeNodes, highlightingEdgeLengthMultiplier);
                            let tempEdges = highlightedEdge.nodes
                            let lineLength = highlightedEdge.length;

                            // Wait for 0.8 second until the next node is highlighted
                            // Draw the next visited path after time Interval
                            setTimeout(() =&gt; {

                                // Append a path that completes drawing wthin a time duration
                                this.container.append(&quot;svg:path&quot;)
                                    .style(&quot;stroke-width&quot;, this.config.edge.baseWidth + edgeWeight)
                                    .style(&quot;stroke&quot;, this.config.edge.visitedColor)
                                    .style(&quot;fill&quot;, &quot;none&quot;)
                                    .attr({
                                        &apos;d&apos;: this.line(tempEdges),
                                        &apos;stroke-dasharray&apos;: lineLength + &quot; &quot; + lineLength,
                                        &apos;stroke-dashoffset&apos;: lineLength
                                    })
                                    .transition()
                                    .duration(this.config.edge.timeInterval)
                                    .attr(&apos;stroke-dashoffset&apos;, 0);

                            }, this.config.edge.timeInterval * vertexIdx);

                            // Draw the next visited vertex after time Interval
                            setTimeout(() =&gt; {
                                /* clear vertices then redraw all the vertices in the grpah */
                                this.vertices
                                    .append(&quot;circle&quot;)
                                    .attr(&quot;class&quot;, d =&gt; {
                                        // if the node is in the path then draw it in a different color
                                        if (this._directedPath.indexOf(d.id) &lt;= (vertexIdx + 1) &amp;&amp;
                                            this._directedPath.indexOf(d.id) &gt; -1) {
                                            return &quot;visitedVertex&quot;;
                                        }
                                    })
                                    .attr(&quot;r&quot;, d =&gt; d.r);

                                // Add a text element to the previously added g element.
                                this._drawText();

                                // Visited path ending condition
                                let endingVertexIdx = this._directedPath.length - 2;
                                if (vertexIdx === endingVertexIdx) {

                                    // If _weightedAdjMat exists, update the _weightedAdjMat adjacency matrix after the visited path finish highlighting within [timeIntervalBetweenCycle/2] milliseconds
                                    if (this._weightedAdjMat) {
                                        setTimeout(() =&gt; {
                                            this._updateChart();
                                        }, this.config.autoPlay.timeIntervalBetweenCycle / 2.0);
                                    }
                                    // If autoplay is on, then restart the cycle after [timeIntervalBetweenCycle] milliseconds
                                    if (this.config.autoPlay.on) {
                                        console.log(&quot;Auto play is on!&quot;);
                                        setTimeout(() =&gt; {
                                            this._triggerSpeakerNodeAutoPlay();
                                        }, this.config.autoPlay.timeIntervalBetweenCycle);
                                    }
                                }

                                // 0.95 is a time offset multiplier to make vertex colored faster since
                                // there is an unknown lag
                            }, this.config.edge.timeInterval * (vertexIdx + 1));

                            // Draw the first vertex when the path start highlighting
                            this.vertices.append(&quot;circle&quot;)
                                .attr(&quot;class&quot;, d =&gt; {
                                    // if the node is in the path then draw it in a different color
                                    if (this._directedPath[0] === d.id) {
                                        return &quot;visitedVertex&quot;;
                                    }
                                })
                                .attr(&quot;r&quot;, d =&gt; d.r);

                            // Add a text element to the previously added g element.
                            this._drawText();
                        }
                    }
                }
            }
        }
    }

    _drawGraph(data) {
        /* Used to redraw the graph on start and when moving */

        this._drawEdges(data);
        this._drawVertices(data);
    }


    _killAllSetTimeOut() {
        // Kill all setTimeOut used to draw the visited path
        for (var i = 1; i &lt; 99999; i++) {
            window.clearInterval(i);
            window.clearTimeout(i);
            if (window.mozCancelAnimationFrame) window.mozCancelAnimationFrame(i); // Firefox
        }
    }

    _clearVisitedPath() {
        /* empty the _directedPath array and redraw the graph */

        this._killAllSetTimeOut();

        // Then clear the path storage
        this._directedPath = [];
        this._drawGraph(this.graphData.data);
    }


    _createCyclingSpeedControlButton() {
        let pgm = this;

        let sliderID = this.divID.substring(1) + &quot;-slider-range&quot;;
        let $DivSlider = $(&quot;&lt;div&gt;&quot;, {
            id: sliderID
        });
        $(this.divID).prepend($DivSlider);
        $(&quot;#&quot; + sliderID).slider({
            range: false, // two buttons caps a range
            min: 2,
            max: 1000,
            value: pgm.config.edge.timeInterval,
            slide: function(event, ui) {
                pgm._cyclingSpeedControlButtonOnClick(ui);
            }
        });

        let sliderWidth = (this._weightedAdjMat === null) ? this.config.transform.width : this._weightedAdjMat.config.transform.width + this.config.transform.width;
        $(&quot;#&quot; + sliderID).css(&quot;width&quot;, sliderWidth + &quot;px&quot;);
    }

    // This function is called by jQuery slider function defined in _createCyclingSpeedControlButton
    _cyclingSpeedControlButtonOnClick(ui) {
        console.log(&quot;Slider Speed: &quot; + ui.value);
        let sphereRad = ui.value;
        this.config.edge.timeInterval = ui.value;
        this.config.autoPlay.timeIntervalBetweenCycle = ui.value;
    }

    _createPlayButton() {
        /* Used to create a play button, it modifies the default button property in button.css */

        var $Button = $(&quot;&lt;div&gt;&quot;, {
            class: &quot;play-button paused&quot;
        });
        var $left = $(&quot;&lt;div&gt;&quot;, {
            class: &quot;left&quot;
        });
        var $right = $(&quot;&lt;div&gt;&quot;, {
            class: &quot;right&quot;
        });
        var $triangle1 = $(&quot;&lt;div&gt;&quot;, {
            class: &quot;triangle-1&quot;
        });
        var $triangle2 = $(&quot;&lt;div&gt;&quot;, {
            class: &quot;triangle-2&quot;
        });

        $(this.divID).prepend($Button);

        $Button.append($left);
        $Button.append($right);
        $Button.append($triangle1);
        $Button.append($triangle2);

        // Update button dimension first
        let resizedButton = Array.min([this.config.transform.height, this.config.transform.width]) / 10.0 * this.config.autoPlay.button.dim;
        let maxButtonSize = 35.0; // The max button size is 40px so that buttons won&apos;t get too big
        this.config.autoPlay.button.dim = (resizedButton &gt; maxButtonSize) ? maxButtonSize : resizedButton;

        $(this.divID + &quot; .play-button&quot;).css(&quot;height&quot;, this.config.autoPlay.button.dim + &quot;px&quot;)
            .css(&quot;width&quot;, this.config.autoPlay.button.dim + &quot;px&quot;);

        $(this.divID + &quot; .triangle-1&quot;).css(&quot;border-right-width&quot;, this.config.autoPlay.button.dim + &quot;px&quot;)
            .css(&quot;border-top-width&quot;, this.config.autoPlay.button.dim / 2.0 + &quot;px&quot;)
            .css(&quot;border-bottom-width&quot;, this.config.autoPlay.button.dim / 2.0 + &quot;px&quot;);

        $(this.divID + &quot; .triangle-2&quot;).css(&quot;border-right-width&quot;, this.config.autoPlay.button.dim + &quot;px&quot;)
            .css(&quot;border-top-width&quot;, this.config.autoPlay.button.dim / 1.9 + &quot;px&quot;)
            .css(&quot;border-bottom-width&quot;, this.config.autoPlay.button.dim / 2.0 + &quot;px&quot;);

        $(this.divID + &quot; .left&quot;).css(&quot;background-color&quot;, this.config.autoPlay.button.color);
        $(this.divID + &quot; .right&quot;).css(&quot;background-color&quot;, this.config.autoPlay.button.color);

        let pgm = this;
        $(this.divID + &quot; .play-button&quot;).click(function() {
            $(this).toggleClass(&quot;paused&quot;);
            if (pgm.config.autoPlay.on) {
                pgm._stopAutoPlay();
            } else {
                pgm._startAutoPlay();
            }
        });
    }



    _triggerSpeakerNodeAutoPlay() {
        /* Triggers a speaker node randomly following the specified distribution */

        let chosen_id;
        // If speaker node is of uniform distribution
        if (this.speakerLayerProbabilityDistribution.length == 0) {
            chosen_id = Math.floor(Math.random() * this.graphData.clusterMat[0].length);
        } else {
            chosen_id = this._chooseRandomAdjVertexFromSpeakerLayer();
        }
        this._triggerSpeakerNode(chosen_id);
    }

    _triggerSpeakerNode(id) {
        /* triggers a speaker node by id, traverse down and draw the visited path. */

        let speakerLayerLength = this.graphData.clusterMat[0].length;

        // Only allow the node to be clicked if it is in the speaker layer
        if (id &lt; speakerLayerLength) {
            let clickedVertexId = parseInt(id, 10);
            this._traverseGraph(clickedVertexId, this.graphData.data);
            log(&quot;visited path = [&quot; + this._directedPath + &quot;]&quot;);
            this._drawGraph(this.graphData.data);
            this._drawVisitedPath(this.graphData.data);

            // testing 
            $(this.divID + &apos; .path strong&apos;).text(this._directedPath);
        } else {
            // Else clear the path
            this._clearVisitedPath();
        }

        // Do not allow user to click
        this._canClick = false;
        setTimeout(() =&gt; this._canClick = true, this.config.edge.timeInterval * (this._directedPath.length - 1));

    }


    //    bindData(gd) {
    //        /* 
    //        Used to bind an existing JSON object or an object literal to 
    //        the graph and render the graph.
    //        */
    //        if (!Utils.isObjLiteral(gd)) {
    //            // If not an object literal must be a JSON, we parse it
    //            gd = JSON.parse(gd);
    //        }
    //
    //        if (!gd || !gd.data) {
    //            throw new Error(&quot;pgm.bindData(gd): Input graph data is invalid input graph data is empty&quot;);
    //        }
    //
    //        if (gd.data.length &lt;= 1) {
    //            throw new Error(&quot;pgm.bindData(gd): Input graph data is empty&quot;);
    //        }
    //
    //        // Add the this.graphData as a class attribute
    //        this.graphData = gd;
    //        this._dataScreening(this.graphData.data);
    //        this._createEdgesInGraphData(this.graphData.data);
    //        if (this.config.background.grid) {
    //            this_drawGrid();
    //        }
    //        this._drawGraph(this.graphData.data);
    //    }


    redraw() {
        /* Use this to redraw the graph after reset edge weights */
        this._createEdgesInGraphData(this.graphData.data);
        this._drawGraph(this.graphData.data);

        return this;
    }


    init() {
        /* Used to initialize and display the graph  after the set up is done*/

        this._dataScreening(this.graphData.data);

        this.setUniformEdgeWeights();

        this._createEdgesInGraphData(this.graphData.data);

        if (this.config.autoPlayable) this._createPlayButton();

        if (this.config.cyclingSpeedControllable) this._createCyclingSpeedControlButton();

        if (this.config.background.grid) this._drawGrid();

        this._drawGraph(this.graphData.data);

        return this;
    }

    getWeightedAdjacencyMatrix() {
        return this._weightedAdjMat;
    }

    setEdgeWeights(id, weights) {
        /* Set adjacent vertex for vertex with id 
            return this pgm to allow setEdgeWeights to be stacked
        */

        if (id === undefined || weights === undefined) {
            throw new Error(&quot;pgm.setEdgeWeights(id, adjVtx) params are not defined.&quot;);
        }

        this.graphData.data[id].edgeWeights = weights;
        this.redraw();

        return this;
    }

    //    this.setLabel = function (id, label) {
    //        /* Set label for vertex */
    //        this.graphData.data[id].label = label;
    //    };

    //    this.getGraphData = function () {
    //        /* Returns the graphData as  JSON object */
    //        let jsonGraphData = Utils.cloneDR(this.graphData);
    //
    //        console.log(jsonGraphData);
    //
    //        // Delete all the edge circular structures in the object
    //        for (let i = 0; i &lt; jsonGraphData.data.length; i++) {
    //            delete(jsonGraphData.data[i].edges);
    //        }
    //
    //        return JSON.stringify(jsonGraphData);
    //    };


    // Used by createCluster()
    _changeNodeRadius(baseRadius) {
        /* 
        Change the speaker layer ndoe radius based on the probability distribution
        probabilityDistribution is the array of probability given to each node in the speaker layer
        set probabilityDistribution=[] for uniform distribution
        */

        let normalizeBaseRadiusMultiplier = 0.4; // increase base radius size
        let normalizeExtraRadiusBasedOnDistributionMultiplier = 0.7; // increase extra radius size

        for (let i = 0; i &lt; this.speakerLayerProbabilityDistribution.length; i++) {
            // Normalize the radius
            let normalizationFactor = 1.0 / this.speakerLayerProbabilityDistribution.length / normalizeExtraRadiusBasedOnDistributionMultiplier;
            this.graphData.data[i].r = (baseRadius * normalizeBaseRadiusMultiplier) + this.graphData.data[i].r * (this.speakerLayerProbabilityDistribution[i] * 1.0) / normalizationFactor;
        }
    }

    createCluster(cMat, probabilityDistribution, changeNodeRadiusBasedOnDistribution) {
        /* 
        Used to create a clusters of nodes (Graphdata) based on the cMat(cluster matrix).
        Also set the speaker layer probabilility distribution and have the option to
        chagne the spekaer nodes radius based on probability
        
        cMat is the cluster matrix. Ex of cluster mat [layer1_label_array, layer2_label_array, layer3_label_array] 
        probabilityDistribution is the array of probability given to each node in the speaker layer
        set probabilityDistribution=[] for uniform distribution
        changeNodeRadiusBasedOnDistribution is the boolean that governs whether nodes radius are affected by its distribution
        */

        // Error checking
        if (probabilityDistribution.length != 0) {
            if (cMat[0].length != probabilityDistribution.length) {
                throw new Error(&quot;pgm.createCluster(): the number of the nodes in the first layer in cMat does not match the length of the probabilityDistribution array&quot;);
            }
            let tempDistTotal = 0;
            for (let i = 0; i &lt; probabilityDistribution.length; i++) {
                tempDistTotal += probabilityDistribution[i];
            }
            if (tempDistTotal != 1.0) {
                throw new Error(&quot;pgm.createCluster(): the probability of each node in the speaker layer does not add up to 1.0 in probabilityDistribution array&quot;);
            }
        }

        this.speakerLayerProbabilityDistribution = probabilityDistribution;

        this.cMatDim = []; //cMatDim is the dimension of the matrix, ex: [3,3,3]

        // Populate cMatDim
        for (let i = 0; i &lt; cMat.length; i++) {
            this.cMatDim[i] = cMat[i].length;
        }

        let offsetPosX = this.config.transform.width / (this.cMatDim.length + 1); // get the x offset for first node
        let minPosY = this.config.transform.height / (Array.max(this.cMatDim) + 1); // get the y offset for the layer with the most amount of nodes

        // Data properties: id, x, y, r 
        let data = [];
        let id = 0;
        let x;
        let y;
        let r = Array.min([offsetPosX, minPosY]) * this.config.vertex.radius;

        this.config.vertex.radius = r;

        for (let i = 0; i &lt; this.cMatDim.length; i++) {
            // Reset offset Y coordinate for each layer
            let offSetPosY = this.config.transform.height / (this.cMatDim[i] + 1);
            for (let j = 0; j &lt; this.cMatDim[i]; j++) {
                x = offsetPosX * (i + 1);
                y = offSetPosY * (j + 1);
                data.push({
                    id: id,
                    x: x,
                    y: y,
                    r: r
                });
                id++;
            }

        }


        // Label each vertex based on cMat labels
        let id_temp = 0;
        for (let i = 0; i &lt; cMat.length; i++)
            for (let j = 0; j &lt; cMat[i].length; j++)
                data[id_temp++].label = cMat[i][j];


        // Update the this.config edge width and baseWidth
        this.config.edge.width = r * this.config.edge.width;
        this.config.edge.baseWidth = r * this.config.edge.baseWidth;


        // Create the graphData member variable in pgm
        this.graphData = {
            clusterMat: cMat,
            data: data
        };

        // Change speaker node radius based on distribution
        if (changeNodeRadiusBasedOnDistribution &amp;&amp; probabilityDistribution.length &gt; 0) this._changeNodeRadius(r);

        return this;
    }


    getGraphData() {
        return this.graphData;
    }


    getVertexId(vertexCoordinate) {
        // get vertex id by coordinate
        // vertexCoordinate is a coordiante pair = [layer index, vertex index at that layer]

        let layerIdx = vertexCoordinate[0];
        let vertexIdx = vertexCoordinate[1];

        if (layerIdx &gt;= this.cMatDim.length || vertexIdx &gt;= this.cMatDim[layerIdx])
            throw new Error(&quot;pgm.getVertexId(): invalid vertex coordinate input, the vertex being accessed does not exist in the graph. Your input vertex coordinate is [&quot; + vertexCoordinate + &quot;], but the dimention of the cluster matrix is [&quot; + this.cMatDim + &quot;].&quot;);

        let id_temp = 0;
        for (let i = 0; i &lt; layerIdx; i++) id_temp += this.cMatDim[i];
        id_temp += vertexIdx;

        return id_temp;
    }


    // Set the graph edge weights to be uniform
    setUniformEdgeWeights() {
        for (let layerIdx = 0; layerIdx &lt; this.cMatDim.length - 1; layerIdx++) {
            for (let vertexIdx = 0; vertexIdx &lt; this.cMatDim[layerIdx]; vertexIdx++) {
                let vertexID = this.getVertexId([layerIdx, vertexIdx]);
                let numOfNodesNextLayer = this.cMatDim[layerIdx + 1];
                let edgeWeights = [];
                for (let i = 0; i &lt; numOfNodesNextLayer; i++) {
                    edgeWeights[i] = {
                        id: this.getVertexId([layerIdx + 1, i]),
                        weight: 1.0 / numOfNodesNextLayer
                    };
                }
                this.setEdgeWeights(vertexID, edgeWeights);
            }
        }
    }


    /*=========== Graphical Model Autoplay ===========*/

    resetChart() {
        /* reset the _weightedAdjMat */
        this._weightedAdjMat.resetMatrixWeight();
        this._weightedAdjMat.redrawMatrix();
    }

    _startAutoPlay() {
        /* called by the play button to start autoplay */
        this._canClick = false;
        if (this._weightedAdjMat) this.resetChart();
        this.config.autoPlay.on = true;
        this._triggerSpeakerNodeAutoPlay();
    }

    _stopAutoPlay() {
        /* called by the stop button to stop autoplay */
        this._canClick = true;
        this.config.autoPlay.on = false;

        this._clearVisitedPath();

        if (this._weightedAdjMat) {
            this._weightedAdjMat.resetMatrixWeight();
            this._weightedAdjMat.resetMatrixColorWeight();
            // this._weightedAdjMat.redrawMatrix();
        }
    }


    /*======== Binding Adjacency Matrix To The Graphical Model =======*/

    _updateChart() {
        /* Used in _drawVisitedPath() to update the adjacency matrix _weightedAdjMat */
        let _rowIdx = this._directedPath[0];
        let _colIdx = this._directedPath[this._directedPath.length - 1];
        if (_rowIdx &lt; 0 || _colIdx &lt; 0) return;

        let _rowLabel = this.graphData.data[_rowIdx].label;
        let _colLabel = this.graphData.data[_colIdx].label;
        let cellToUpdate = [_rowLabel, _colLabel];
        log(&quot;Update Cell: [&quot; + cellToUpdate + &quot;]&quot;);
        this._weightedAdjMat.increaseCellWeight(cellToUpdate, 1);
        this._weightedAdjMat.increaseCellColor(cellToUpdate, 1);
        this._weightedAdjMat.redrawMatrix();
    }

    //    bindChart (_weightedAdjMat) {
    //        /* Used to bind to an existing adjacency matrix _weightedAdjMatf to the graphical model */
    //        if (this._weightedAdjMat != null) {
    //            this._weightedAdjMat = _weightedAdjMat;
    //        } else {
    //            throw new Error(&quot;pgm.bindChart(): Graph already has a _weightedAdjMat object.&quot;)
    //        }
    //    }

    createAdjacencyMatrix(chartConfig) {
        /* Create a _weightedAdjMat and bind to the graphic model */

        this.chartConfig = chartConfig;

        if (this.graphData.clusterMat.length &lt; 2) {
            throw new Error(&quot;pgm.createAdjacencyMatrix(): Can not create adjacency matrix for graphical model with layer number less than 2&quot;);
            return;
        }
        var _rowLabel = this.graphData.clusterMat[0];
        var _colLabel = this.graphData.clusterMat[this.graphData.clusterMat.length - 1];
        this._weightedAdjMat = new WeightedAdjacencyMatrix(this.divID, chartConfig);
        this._weightedAdjMat.createMatrix(_rowLabel, _colLabel);

        return this;
    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
