<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/listenerObserverPGM.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/listenerObserverPGM.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*=============================================================*/
/*=================== ListenerObserverPGM =====================*/
/*=============================================================*/

&quot;use strict&quot;;


// A wrapper that combines both listenerBeliefPGM and ListenerPGM
class ListenerObserverPGM {

    constructor(divID, listenerBeliefConfig, listenerConfig, adjMatConfig, cMat, speakerLayerProbabilityDistribution, changeNodeRadiusBasedOnDistribution) {

        this.divID = divID;
        // parepare two id html elemnts for both listener and listener&apos;s belief pgms
        let listenerBeliefID = divID + &quot;ListenerBeliefPGM&quot;;
        let listenerID = divID + &quot;ListenerPGM&quot;;

        let $listenerBelief = $(&quot;&lt;div&gt;&quot;, {
            id: listenerBeliefID.substring(1)
        });
        let $listener = $(&quot;&lt;div&gt;&quot;, {
            id: listenerID.substring(1)
        });

        $(this.divID).append($listenerBelief);
        $(this.divID).append($listener);

        // Creating ListenerBeliefPGM first
        this.listenerBelif = new ListenerBeliefPGM(listenerBeliefConfig, listenerBeliefID)
            .createCluster(cMat, speakerLayerProbabilityDistribution, changeNodeRadiusBasedOnDistribution)
            .createAdjacencyMatrix(adjMatConfig)
            .init();

        // Add image
        // this.listenerBelif.svg.append(&quot;svg:image&quot;)
        //     .attr(&apos;x&apos;, -9)
        //     .attr(&apos;y&apos;, -12)
        //     .attr(&apos;width&apos;, 200)
        //     .attr(&apos;height&apos;, 200)
        //     .attr(&quot;xlink:href&quot;, &quot;img/1.png&quot;);

        // Then create ListenerPGM first based on the configuration
        // and bind the data to the graph for rendering
        let listenerClusterMatrix = [cMat[1], cMat[0]]; // mirror image of the belisef graph
        this.listener = new ListenerPGM(listenerConfig, listenerID)
            .createCluster(listenerClusterMatrix, [], true)
            .init();

        this.listener.bindToListenerBeliefPGM(this.listenerBelif)
    }


    setEdgeWeights(vertexId, adjacentEdgeWeights) {
        this.listenerBelif.setEdgeWeights(vertexId, adjacentEdgeWeights);
        this.listener.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();
        return this;
    }

}


/* 
ListenerBeliefPGM is composed of ListenerPGM
*/
class ListenerBeliefPGM extends GraphicalModel {

    constructor(graphConfiguration, divID) {

        super(graphConfiguration, divID);

        // Creates the dialgue box here
        this._createDialogueBox();
    }


    _createDialogueBox() {
        /* This method creates the dialogue box for listener&apos;s belief to achieve thought bubble effect.
        The dialogue box is consisited of resized background rect from the listener&apos;s belief PGM and 
        a small upsidedown triangle, which is used to give the feeling of a dialgoue bubble */

        let rectX = this.config.transform.width / 4,
            rectY = this.config.transform.height * 2 / 15,
            rectWidth = this.config.transform.width / 2,
            rectHeight = this.config.transform.height * 3 / 4,
            rectCornorRadius = this.config.transform.width / 15;
        this.rect
            .attr(&quot;class&quot;, &quot;background&quot;)
            .attr(&quot;x&quot;, rectX)
            .attr(&quot;y&quot;, rectY)
            .attr(&quot;rx&quot;, rectCornorRadius)
            .attr(&quot;ry&quot;, rectCornorRadius)
            .attr(&quot;width&quot;, rectWidth)
            .attr(&quot;height&quot;, rectHeight)
            .style(&quot;fill&quot;, this.config.background.color)
            .style(&quot;pointer-events&quot;, &quot;all&quot;)
            .on(&quot;click&quot;, d =&gt; {
                pgm._backgroundOnClick();
            });

        let offSet = -1,
            trianglePoint1 = [rectX + rectWidth / 3, rectY + rectHeight + offSet],
            trianglePoint2 = [rectX + rectWidth / 2, this.config.transform.height],
            trianglePoint3 = [rectX + rectWidth * 2 / 3, rectY + rectHeight + offSet];
        let trianglePath = trianglePoint1[0] + &quot;,&quot; + trianglePoint1[1] + &quot;, &quot; + trianglePoint2[0] + &quot;,&quot; + trianglePoint2[1] + &quot;, &quot; + trianglePoint3[0] + &quot;,&quot; + trianglePoint3[1];
        this.svg.append(&quot;polygon&quot;) // attach a polygon
        .style(&quot;fill&quot;, this.config.background.color)
            .attr(&quot;points&quot;, trianglePath);
    }

    _calculateWeights() {
        /*
            returns the normalized weights in a 1D array in the form of Wij, ex, [W_sub(1,1), W_sub(1,2), W_sub(2,1), W_sub(2,2)]
        */
        let weight = [];

        let firstLayerLength = this.graphData.clusterMat[0].length;
        let lastLayerLength = this.graphData.clusterMat[this.graphData.clusterMat.length - 1].length;
        // Calculate the new edge weights based on adj matrix
        for (let i = 0; i &lt; firstLayerLength; i++) {
            for (let j = 0; j &lt; lastLayerLength; j++) {
                let M_ij = this.getWeightedAdjacencyMatrix().getCellWeight([i, j]);
                let Mij_summation_over_j = 0;
                for (let sigma_sub_j = 0; sigma_sub_j &lt;= j; sigma_sub_j++) {
                    Mij_summation_over_j += this.getWeightedAdjacencyMatrix().getCellWeight([i, sigma_sub_j]);
                }
                // log([M_ij, Mij_summation_over_j])
                let W_ij = (M_ij === 0) ? 0 : M_ij / Mij_summation_over_j;
                weight.push(W_ij);
            }
        }

        log(&quot;Weight = &quot; + weight);

        // Noralize the weights so that all node&apos;s edge weights sum up to 1

        let vertexWeightSumTemp = []; // each element is the weight sum for a vertex
        let weightIdx = 1;
        let tempWeightSumForVertex = 0;
        for (let i = 0; i &lt; weight.length; i++) {
            tempWeightSumForVertex += weight[i];
            if (weightIdx % firstLayerLength == 0) {
                // push vertex sum &quot;firstLayerLength&quot; many times so its easier to normalize weight
                for (let j = 0; j &lt; firstLayerLength; j++) {
                    vertexWeightSumTemp.push(tempWeightSumForVertex);
                }
                tempWeightSumForVertex = 0;
            }
            weightIdx++;
        }

        log(&quot;vertexWeightSumTemp = &quot; + vertexWeightSumTemp);

        // Normalize
        let normalizedWeight = [];
        for (let i = 0; i &lt; weight.length; i++) {
            normalizedWeight[i] = (vertexWeightSumTemp[i] === 0) ? 0 : weight[i] / vertexWeightSumTemp[i];
        }

        log(&quot;normalized weight = &quot; + normalizedWeight);

        return normalizedWeight;
    }

    _cyclingSpeedControlButtonOnClick(ui) {
        super._cyclingSpeedControlButtonOnClick(ui);
        // updating listenerPGM&apos;s speed on button click as well
        this.listenerPGM.config.edge.timeInterval = ui.value;
        this.listenerPGM.config.autoPlay.timeIntervalBetweenCycle = ui.value;
    }

    /*@Override*/
    _updateChart() {
        // After updating the chart updating the weight in ListenerPGM as well
        super._updateChart();

        let updatedWeights = this._calculateWeights()
        this.listenerPGM.updateWeight(updatedWeights);
        this.listenerPGM.redraw();
    }

    /*@Override*/
    // _backgroundOnClickToResetAdjMatrix() {
    //     // overrie original function so when background is clicked the matrix won&apos;t reset
    //     return false;
    // }
    // _backgroundOnClick() {}

    /*@Override*/
    _stopAutoPlay() {
        super._stopAutoPlay();
        // When stop button is clicked, reset the listenerPGM edgeweights as well
        // this.listenerPGM.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();
        // this.listenerPGM.redraw();
    }

    /*@Override*/
    _startAutoPlay() {
        /* When stop button is clicked, reset the listenerPGM edgeweights as well */


        // Stop listenerPGM autoplay before calling super._startPlay() so that _clearVisitedPath() method won&apos;t destroy both listenerPGM&apos;s autoPlay and this graph&apos;s autoPlay
        if (this.listenerPGM.config.autoPlay.on) {
            this.listenerPGM._stopAutoPlay();
        }

        super._startAutoPlay();

        // reset the listenerPGM edge weights
        this.listenerPGM.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();
        this.listenerPGM.redraw();
    }

    /* @Override */
    createCluster(cMat, probabilityDistribution, changeNodeRadiusBasedOnDistribution) {

        this.listenerClusterMatrix = [cMat[1], cMat[0]]; // mirror image of the belisef graph
        this.listenerBeliefClusterMatrix = cMat;

        if (cMat.length != 2)
            throw new Error(&quot;ListenerBeliefPGM.createCluster(): invalid cMat length. This graph only supports two layer graphs.&quot;);
        super.createCluster(this.listenerBeliefClusterMatrix, probabilityDistribution, changeNodeRadiusBasedOnDistribution);
        return this;
    }


    bindToListenerPGM(listener) {
        // Used to bind listenerPGM to listenerBeliefPGM
        this.listenerPGM = listener;
        return this;
    }
}



class ListenerPGM extends GraphicalModel {

    constructor(graphConfiguration, divID) {
        super(graphConfiguration, divID);
    }


    /*@Override*/
    _updateChart() {}

    /*@Override*/
    _backgroundOnClick() {
        // Prevent adjMatrix gets reset when click on background
        if (this._canClick &amp;&amp; !this.listenerBeliefPGM.config.autoPlay.on) {
            super._backgroundOnClick();
        }
    }


    resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights() {
        // Set listenerPGM to be listenerBeliefPGM&apos;s mirror
        let weights = [];
        for (let i = 0; i &lt; this.cMatDim[0]; i++) {
            for (let vertexIdx = 0; vertexIdx &lt; this.listenerBeliefPGM.cMatDim[0]; vertexIdx++) {
                let listenerEdgeWeights = this.listenerBeliefPGM.getGraphData().data[vertexIdx].edgeWeights;
                weights.push(listenerEdgeWeights[i].weight);
            }
        }
        this.updateWeight(weights);
    }

    bindToListenerBeliefPGM(belief) {
        // This binds the listener and the listener&apos;s belief to each other and set listener&apos;s weight.
        belief.bindToListenerPGM(this);
        this.listenerBeliefPGM = belief;

        let listenerPGM = this;
        // Redefine onClick when bind to listenerBeliefPGM to prevent adjMatrix gets reset when click on background
        this.onClick = d3.behavior.drag()
            .origin(d =&gt; d)
            .on(&quot;dragstart&quot;, function(d) {
                // Check if the clicked node is in the first layer
                // which are the num of nodes in first layer of clusterMat
                // Only allow user to click the node if autoplay is off
                if (!listenerPGM.listenerBeliefPGM.config.autoPlay.on) {
                    d3.event.sourceEvent.stopPropagation();
                    d3.select(this).classed(&quot;dragging&quot;, true);

                    // Option 1: Only draw visited path once
                    // listenerPGM._triggerSpeakerNode(this.id);

                    // Option 2: AutoPlay when speaker node is clicked
                    let speakerLayerLength = listenerPGM.graphData.clusterMat[0].length;
                    if (listenerPGM.config.autoPlay.on) {
                        listenerPGM._stopAutoPlay();
                    } else {
                        listenerPGM._startAutoPlay();
                    }
                }
            });
        this.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();

        return this;
    }


    updateWeight(weight) {
        // Used by listenerBelief to update the pgm weigth
        // takes in the weights as an 1D array and set the weights
        let weightIdx = 0;
        for (let vertexIdx = 0; vertexIdx &lt; this.cMatDim[0]; vertexIdx++) {
            let edgeWeights = [];
            for (let i = 0; i &lt; this.cMatDim[1]; i++) {
                edgeWeights[i] = {
                    id: this.getVertexId([1, i]),
                    weight: weight[weightIdx]
                };
                weightIdx++;
            }
            this.setEdgeWeights(vertexIdx, edgeWeights);
        }
    }


}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
