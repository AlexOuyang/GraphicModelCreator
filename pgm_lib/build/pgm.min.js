/*=============== Probability Graphic Model ====================*/

"use strict";

/**
 * This is the regulra probability Graphical Model that supports auto play loops and zoom in ability. It is the basis of ListenerObserver_pgm.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
};

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return getter.call(receiver);
    }
};

var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var GraphicalModel = function() {

    /**
     * This is GraphicalModel constructor description.
     * @param {object} - graphConfiguration is a configuration object for configuring the properties of this _pgm, it can be obtained via Config.getPGMConfig().
     * @param {string} - divID is the id of the html tag that contains this pgm, it is of the form '#id_name'.
     */

    function GraphicalModel(graphConfiguration, divID) {
        var _this = this;

        _classCallCheck(this, GraphicalModel);

        this.config = graphConfiguration;

        this.graphData = {
            clusterMat: [], // data specifies the nodes in each layer
            data: [] // data binds to the graph
        };

        this._weightedAdjMat = null; // Holds the adjacency matrix chart

        this._directedPath = []; // _directedPath is a list of visited nodes' ID

        this._canClick = true; // Used to keep user from clicking when the graph is traversing

        this._speakerLayerProbabilityDistribution = []; //  an array of probability given to each node in the speaker layer, probabilityDistribution=[] if uniform distribution

        var _pgm = this;

        this._divID = divID;

        // Click on the node in the speaker layer to draw visited path
        this.onClick = d3.behavior.drag().origin(function(d) {
            return d;
        }).on("dragstart", function(d) {
            // Check if the clicked node is in the first layer
            // which are the num of nodes in first layer of clusterMat
            // Only allow user to click the node if autoplay is off
            if (_pgm._canClick && !_pgm.config.autoPlayable) {
                d3.event.sourceEvent.stopPropagation();
                d3.select(this).classed("dragging", true);
                _pgm._triggerSpeakerNode(this.id);
            }
        });

        this.svg = d3.select(divID).append("svg").attr("class", "graph").attr("width", this.config.transform.width).attr("height", this.config.transform.height).append("g").attr("transform", "translate(" + this.config.transform.x + "," + this.config.transform.y + ")");

        // Set up the background rect wrapper
        this.rect = this.svg.append("rect").attr("class", "background").attr("width", this.config.transform.width).attr("height", this.config.transform.height).style("fill", this.config.background.color).style("pointer-events", "all").on("click", function(d) {
            _pgm._backgroundOnClick();
        });

        this.container = this.svg.append("g");

        // Specify the function for generating path data  
        // "linear" for piecewise linear segments
        // Creating path using data in pathinfo and path data generator
        // Used in _drawEdges() and _drawVisitedPath();
        this.line = d3.svg.line().x(function(d) {
            return d.x;
        }).y(function(d) {
            return d.y;
        }).interpolate("linear");

        this.vertices = null; // D3 object, initiated in drawVertices()

        // Zoom behavior
        this.zoom = d3.behavior.zoom().scaleExtent([1, 10]).on("zoom", function() {
            _this.container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        });

        // Zoom behavior
        if (this.config.zoomable) {
            this.svg.call(this.zoom);
        }
    }

    _createClass(GraphicalModel, [{
        key: "_backgroundOnClickToResetAdjMatrix",
        value: function _backgroundOnClickToResetAdjMatrix() {
            if (this._weightedAdjMat) {
                this._weightedAdjMat.resetMatrixWeight();
                this._weightedAdjMat.resetMatrixColorWeight();
                this._weightedAdjMat.redrawMatrix();
            }
        }
    }, {
        key: "_backgroundOnClick",
        value: function _backgroundOnClick() {
            var _this2 = this;

            if (!this.config.autoPlayable) {
                if (this._canClick && !this.config.autoPlay.on) {
                    this._clearVisitedPath();
                    // Do not allow user to click until visited path highlighting is finished
                    this._canClick = false;
                    setTimeout(function() {
                        return _this2._canClick = true;
                    }, this.config.edge.timeInterval * (this._directedPath.length - 1));

                    // click on background to reset adjacency matrix
                    this._backgroundOnClickToResetAdjMatrix();
                }
            }
        }
    }, {
        key: "_dataScreening",
        value: function _dataScreening(data) {
            /* Verifies if each vertex's id matches its position in the array 
            and the weights of all adjacent vertices sum to 1; */

            if (data.length <= 1) {
                throw new Error("input graph data is empty");
            }

            var weightSum = 0;
            for (var vertexIdx = 0; vertexIdx < data.length; vertexIdx++) {
                if (data[vertexIdx].id !== vertexIdx) {
                    throw new Error("Vertex's id must match its position index in the list of vertices. The " + vertexIdx + " th element in the list does not match its position index");
                }
                var allEdgeZero = true;
                var adjVertices = data[vertexIdx].edgeWeights;
                if (adjVertices) {
                    // Check if all edges have weight 0

                    for (var i = 0; i < adjVertices.length; i++) {
                        weightSum += adjVertices[i].weight;
                        if (adjVertices[i].weight !== 0) allEdgeZero = false;
                    }

                    if (weightSum !== 1.0 && allEdgeZero === false) {
                        throw new Error("The sum of a vertex's adjacent edge's weight must be 1 or all edges have a weight of 0. " + "The " + vertexIdx + "th vertex is invalid.");
                    }
                }
                weightSum = 0;
            }
        }
    }, {
        key: "_createEdgesInGraphData",
        value: function _createEdgesInGraphData(data) {
            // Takes in the graph data, modifies the data by adding a list of edges into the data and add to self  
            if (data.length <= 1) {
                throw new Error("input graph data is empty");
            }

            // Go through each vertex in data and add 'edges' attribute to each vertex
            for (var vertexIdx = 0; vertexIdx < data.length; vertexIdx++) {
                var currentVertex = data[vertexIdx];
                if (!currentVertex.edgeWeights) {
                    currentVertex.edges = null;
                } else {
                    currentVertex.edges = [];
                    for (var adjVertexIdx = 0; adjVertexIdx < currentVertex.edgeWeights.length; adjVertexIdx++) {
                        var targetVertexId = currentVertex.edgeWeights[adjVertexIdx].id;
                        var targetVertexWeight = currentVertex.edgeWeights[adjVertexIdx].weight;

                        var edge = {
                            edgeWeight: targetVertexWeight,
                            edgeNodes: [currentVertex, data[targetVertexId]]
                        };

                        currentVertex.edges.push(edge);
                    }
                }
            }
        }
    }, {
        key: "_chooseRandomAdjVertexFromSpeakerLayer",
        value: function _chooseRandomAdjVertexFromSpeakerLayer() {
            /*
            Choose a random adjacent vertex in the speaker layer based on the edge weights 
            */
            var weightDistribution = [0]; // weightDistribution is a distribution from 0 to 1, ex: [0, 0.4, 1]
            var weight = 0;
            for (var i = 0; i < this._speakerLayerProbabilityDistribution.length; i++) {
                weight += this._speakerLayerProbabilityDistribution[i];
                weightDistribution.push(weight);
            }

            var randomPick = Math.random();
            console.log("weight distribution corresponding to the speaker layer: (" + weightDistribution + ") random pick: " + randomPick);
            for (var _i = 0; _i < weightDistribution.length - 1; _i++) {
                if (randomPick >= weightDistribution[_i] && randomPick <= weightDistribution[_i + 1]) {
                    return this.graphData.data[_i].id;
                }
            }
        }
    }, {
        key: "_chooseRandomAdjVertex",
        value: function _chooseRandomAdjVertex(vertex) {
            /*
            Takes in a vertex and choose a random adjacent vertex in the next layer based on the edge weights 
            */
            var weightDistribution = [0]; // weightDistribution is a distribution from 0 to 1, ex: [0, 0.4, 1]
            var weight = 0;
            for (var i = 0; i < vertex.edgeWeights.length; i++) {
                weight += vertex.edgeWeights[i].weight;
                weightDistribution.push(weight);
            }

            var randomPick = Math.random();
            console.log("weight distribution corresponding to adjacent vertices in the next layer: (" + weightDistribution + ") random pick: " + randomPick);

            // if the sum of distribution is 0 then return -1
            var distributionSum = weightDistribution.reduce(function(a, b) {
                return a + b;
            }, 0);
            if (distributionSum === 0) {
                return -1;
            }

            for (var _i2 = 0; _i2 < weightDistribution.length - 1; _i2++) {
                if (randomPick >= weightDistribution[_i2] && randomPick <= weightDistribution[_i2 + 1]) {
                    return vertex.edgeWeights[_i2].id;
                }
            }
        }
    }, {
        key: "_traverseGraph",
        value: function _traverseGraph(vertexId, data) {
            /* 
            Takes in the id of a node and traverse trough the graph to connect 
            impacted nodes and returns the id of the visited node
            */

            var visitedNodes = [vertexId];
            var node = data[vertexId];

            while (node !== undefined && node.edgeWeights !== undefined) {
                console.log("Current Vertex: " + vertexId);
                vertexId = this._chooseRandomAdjVertex(node);
                // if (vertexId < 0) break;
                console.log("Vextex chosen: " + vertexId);
                console.log("--------");
                node = data[vertexId];
                visitedNodes.push(vertexId);
            }

            this._directedPath = visitedNodes;
        }
    }, {
        key: "_drawGrid",
        value: function _drawGrid() {
            /* Draws the axis in the background */

            this.container.append("g").attr("class", "x axis").selectAll("line").data(d3.range(0, this.config.transform.width, 10)).enter().append("line").attr("x1", function(d) {
                return d;
            }).attr("y1", 0).attr("x2", function(d) {
                return d;
            }).attr("y2", this.config.transform.height);

            this.container.append("g").attr("class", "y axis").selectAll("line").data(d3.range(0, this.config.transform.height, 10)).enter().append("line").attr("x1", 0).attr("y1", function(d) {
                return d;
            }).attr("x2", this.config.transform.width).attr("y2", function(d) {
                return d;
            });
        }
    }, {
        key: "_drawText",
        value: function _drawText() {
            var _this3 = this;

            /* Add a text element to the previously added g element. */
            this.vertices.append("text").attr("font-size", function(d) {
                return d.r * _this3.config.text.size;
            }).attr("text-anchor", this.config.text.anchor).attr("alignment-baseline", this.config.text.alignment).attr("fill", this.config.text.color).text(function(d) {
                if (d.label) {
                    return d.label;
                } else {
                    return d.id;
                }
            });
        }
    }, {
        key: "_drawVertices",
        value: function _drawVertices(data) {
            /* clear vertices then redraw all the vertices in the grpah */

            d3.selectAll(this._divID + " g .vertex").remove();

            // Create vertex groups, each group contains a cicle and a text
            this.vertices = this.container.append("g").attr("class", "vertex").selectAll("circle").data(data).enter().append("g").attr("id", function(d) {
                return d.id;
            }).attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            }).call(this.onClick);

            this.vertices.append("circle").attr("r", function(d) {
                return d.r;
            });

            this._drawText();
        }
    }, {
        key: "_drawEdges",
        value: function _drawEdges(data) {
            /* Draw all edges and high light visited color */

            // clear edges then redraw all the edges in the graph
            d3.selectAll(this._divID + " path").remove();

            // Draw all edges based on weight in default color
            for (var vertexIdx = 0; vertexIdx < data.length; vertexIdx++) {
                // Iterate through each nodes in data
                var currentVertex = data[vertexIdx];
                if (currentVertex.edges) {
                    for (var edgeIdx = 0; edgeIdx < currentVertex.edges.length; edgeIdx++) {
                        // Iterate through each edge in the current node
                        var edgeNodes = currentVertex.edges[edgeIdx].edgeNodes;
                        var edgeWeight = currentVertex.edges[edgeIdx].edgeWeight * this.config.edge.width;
                        this.container.append("svg:path").attr("d", this.line(edgeNodes)).attr("stroke-width", edgeWeight + this.config.edge.baseWidth).style("stroke", this.config.edge.defaultColor).style("fill", "none");
                    }
                }
            }
        }

        /* EdgeNodes contains a pair of nodes (e.g. [node1, node2]) which are two ends of an edge, lengthMultiplier is used to determine the magnitude of the edge
         @returns a highlightedEdge objects that contains the nodes information and the length information
         */

    }, {
        key: "_drawHighlightedEdge",
        value: function _drawHighlightedEdge(edgeNodes, lengthMultiplier) {
            var x0 = edgeNodes[0].x,
                y0 = edgeNodes[0].y,
                r0 = edgeNodes[0].r,
                x1 = edgeNodes[1].x,
                y1 = edgeNodes[1].y,
                r1 = edgeNodes[1].r,
                distX = x1 - x0,
                distY = y0 - y1,
                dist = Math.sqrt(distX * distX + distY * distY),
                ratio0 = r0 / (lengthMultiplier * dist),
                ratio1 = r1 / (lengthMultiplier * dist),


                // tempEdges for highlighting the visited edges
                highlightedEdgeNodes = [{
                    x: x0 + distX * ratio0,
                    y: y0 - distY * ratio0
                }, {
                    x: x1 - distX * ratio1,
                    y: y1 + distY * ratio1
                }];

            var highlightedEdge = {
                nodes: highlightedEdgeNodes,
                length: dist
            };

            return highlightedEdge;
        }
    }, {
        key: "_drawVisitedPath",
        value: function _drawVisitedPath(data) {
            var _this4 = this;

            var _loop = function _loop(vertexIdx) {

                // check if there's -1 in _directedPath, if yes, do not draw the path and trigger a new speaker
                if (_this4._directedPath[vertexIdx] < 0) {

                    // Draw the first vertex when the path start highlighting
                    _this4.vertices.append("circle").attr("class", function(d) {
                        // if the node is in the path then draw it in a different color
                        if (_this4._directedPath[0] === d.id) {
                            return "visitedVertex";
                        }
                    }).attr("r", function(d) {
                        return d.r;
                    });

                    // Add a text element to the previously added g element.
                    _this4._drawText();

                    setTimeout(function() {

                        // If autoplay is on, then restart the cycle after [timeIntervalBetweenCycle] milliseconds
                        if (_this4.config.autoPlay.on) {
                            console.log("Auto play is on!");
                            setTimeout(function() {
                                _this4._triggerSpeakerNodeAutoPlay();
                            }, _this4.config.autoPlay.timeIntervalBetweenCycle);
                        }
                    }, _this4.config.edge.timeInterval);
                } else {

                    // If there's no -1 in directed path
                    // Iterate through the list of ID in _directedPath
                    var currentVertex = data[_this4._directedPath[vertexIdx]];
                    if (currentVertex.edges) {
                        var _loop2 = function _loop2(edgeIdx) {
                            var edgeNodes = currentVertex.edges[edgeIdx].edgeNodes;
                            var edgeWeight = currentVertex.edges[edgeIdx].edgeWeight * _this4.config.edge.width;
                            // If the edge is in the _directedPath then draw different color
                            if (_this4._directedPath.indexOf(edgeNodes[0].id) > -1 && _this4._directedPath.indexOf(edgeNodes[1].id) > -1) {
                                (function() {

                                    // Create two new points to draw a shorter edge so the new
                                    // edge will not cover the id in the node
                                    var highlightingEdgeLengthMultiplier = 1.1; // Used to increase the length of the highlighted edge on both ends;
                                    var highlightedEdge = _this4._drawHighlightedEdge(edgeNodes, highlightingEdgeLengthMultiplier);
                                    var tempEdges = highlightedEdge.nodes;
                                    var lineLength = highlightedEdge.length;

                                    // Wait for 0.8 second until the next node is highlighted
                                    // Draw the next visited path after time Interval
                                    setTimeout(function() {

                                        // Append a path that completes drawing wthin a time duration
                                        _this4.container.append("svg:path").style("stroke-width", _this4.config.edge.baseWidth + edgeWeight).style("stroke", _this4.config.edge.visitedColor).style("fill", "none").attr({
                                            'd': _this4.line(tempEdges),
                                            'stroke-dasharray': lineLength + " " + lineLength,
                                            'stroke-dashoffset': lineLength
                                        }).transition().duration(_this4.config.edge.timeInterval).attr('stroke-dashoffset', 0);
                                    }, _this4.config.edge.timeInterval * vertexIdx);

                                    // Draw the next visited vertex after time Interval
                                    setTimeout(function() {
                                        /* clear vertices then redraw all the vertices in the grpah */
                                        _this4.vertices.append("circle").attr("class", function(d) {
                                            // if the node is in the path then draw it in a different color
                                            if (_this4._directedPath.indexOf(d.id) <= vertexIdx + 1 && _this4._directedPath.indexOf(d.id) > -1) {
                                                return "visitedVertex";
                                            }
                                        }).attr("r", function(d) {
                                            return d.r;
                                        });

                                        // Add a text element to the previously added g element.
                                        _this4._drawText();

                                        // Visited path ending condition
                                        var endingVertexIdx = _this4._directedPath.length - 2;
                                        if (vertexIdx === endingVertexIdx) {

                                            // If _weightedAdjMat exists, update the _weightedAdjMat adjacency matrix after the visited path finish highlighting within [timeIntervalBetweenCycle/2] milliseconds
                                            if (_this4._weightedAdjMat) {
                                                setTimeout(function() {
                                                    _this4._updateChart();
                                                }, _this4.config.autoPlay.timeIntervalBetweenCycle / 2.0);
                                            }
                                            // If autoplay is on, then restart the cycle after [timeIntervalBetweenCycle] milliseconds
                                            if (_this4.config.autoPlay.on) {
                                                console.log("Auto play is on!");
                                                setTimeout(function() {
                                                    _this4._triggerSpeakerNodeAutoPlay();
                                                }, _this4.config.autoPlay.timeIntervalBetweenCycle);
                                            }
                                        }

                                        // 0.95 is a time offset multiplier to make vertex colored faster since
                                        // there is an unknown lag
                                    }, _this4.config.edge.timeInterval * (vertexIdx + 1));

                                    // Draw the first vertex when the path start highlighting
                                    _this4.vertices.append("circle").attr("class", function(d) {
                                        // if the node is in the path then draw it in a different color
                                        if (_this4._directedPath[0] === d.id) {
                                            return "visitedVertex";
                                        }
                                    }).attr("r", function(d) {
                                        return d.r;
                                    });

                                    // Add a text element to the previously added g element.
                                    _this4._drawText();
                                })();
                            }
                        };

                        for (var edgeIdx = 0; edgeIdx < currentVertex.edges.length; edgeIdx++) {
                            _loop2(edgeIdx);
                        }
                    }
                }
            };

            /* Draw visited edges based on weight in highlighted color */

            for (var vertexIdx = 0; vertexIdx < this._directedPath.length; vertexIdx++) {
                _loop(vertexIdx);
            }
        }
    }, {
        key: "_drawGraph",
        value: function _drawGraph(data) {
            /* Used to redraw the graph on start and when moving */

            this._drawEdges(data);
            this._drawVertices(data);
        }
    }, {
        key: "_killAllSetTimeOut",
        value: function _killAllSetTimeOut() {
            // Kill all setTimeOut used to draw the visited path
            for (var i = 1; i < 99999; i++) {
                window.clearInterval(i);
                window.clearTimeout(i);
                if (window.mozCancelAnimationFrame) window.mozCancelAnimationFrame(i); // Firefox
            }
        }
    }, {
        key: "_clearVisitedPath",
        value: function _clearVisitedPath() {
            /* empty the _directedPath array and redraw the graph */

            this._killAllSetTimeOut();

            // Then clear the path storage
            this._directedPath = [];
            this._drawGraph(this.graphData.data);
        }
    }, {
        key: "_createCyclingSpeedControlButton",
        value: function _createCyclingSpeedControlButton() {
            var _pgm = this;

            var sliderID = this._divID.substring(1) + "-slider-range";
            var $DivSlider = $("<div>", {
                id: sliderID
            });
            $(this._divID).prepend($DivSlider);
            $("#" + sliderID).slider({
                range: false, // two buttons caps a range
                min: 2,
                max: 1000,
                value: _pgm.config.edge.timeInterval,
                slide: function slide(event, ui) {
                    _pgm._cyclingSpeedControlButtonOnClick(ui);
                }
            });

            var sliderWidth = this._weightedAdjMat === null ? this.config.transform.width : this._weightedAdjMat.config.transform.width + this.config.transform.width;
            $("#" + sliderID).css("width", sliderWidth + "px");
        }

        // This function is called by jQuery slider function defined in _createCyclingSpeedControlButton

    }, {
        key: "_cyclingSpeedControlButtonOnClick",
        value: function _cyclingSpeedControlButtonOnClick(ui) {
            console.log("Slider Speed: " + ui.value);
            var sphereRad = ui.value;
            this.config.edge.timeInterval = ui.value;
            this.config.autoPlay.timeIntervalBetweenCycle = ui.value;
        }
    }, {
        key: "_createPlayButton",
        value: function _createPlayButton() {
            /* Used to create a play button, it modifies the default button property in button.css */

            var $Button = $("<div>", {
                class: "play-button paused"
            });
            var $left = $("<div>", {
                class: "left"
            });
            var $right = $("<div>", {
                class: "right"
            });
            var $triangle1 = $("<div>", {
                class: "triangle-1"
            });
            var $triangle2 = $("<div>", {
                class: "triangle-2"
            });

            $(this._divID).prepend($Button);

            $Button.append($left);
            $Button.append($right);
            $Button.append($triangle1);
            $Button.append($triangle2);

            // Update button dimension first
            var resizedButton = Array.min([this.config.transform.height, this.config.transform.width]) / 10.0 * this.config.autoPlay.button.dim;
            var maxButtonSize = 35.0; // The max button size is 40px so that buttons won't get too big
            this.config.autoPlay.button.dim = resizedButton > maxButtonSize ? maxButtonSize : resizedButton;

            $(this._divID + " .play-button").css("height", this.config.autoPlay.button.dim + "px").css("width", this.config.autoPlay.button.dim + "px");

            $(this._divID + " .triangle-1").css("border-right-width", this.config.autoPlay.button.dim + "px").css("border-top-width", this.config.autoPlay.button.dim / 2.0 + "px").css("border-bottom-width", this.config.autoPlay.button.dim / 2.0 + "px");

            $(this._divID + " .triangle-2").css("border-right-width", this.config.autoPlay.button.dim + "px").css("border-top-width", this.config.autoPlay.button.dim / 1.9 + "px").css("border-bottom-width", this.config.autoPlay.button.dim / 2.0 + "px");

            $(this._divID + " .left").css("background-color", this.config.autoPlay.button.color);
            $(this._divID + " .right").css("background-color", this.config.autoPlay.button.color);

            var _pgm = this;
            $(this._divID + " .play-button").click(function() {
                $(this).toggleClass("paused");
                if (_pgm.config.autoPlay.on) {
                    _pgm._stopAutoPlay();
                } else {
                    _pgm._startAutoPlay();
                }
            });
        }
    }, {
        key: "_triggerSpeakerNodeAutoPlay",
        value: function _triggerSpeakerNodeAutoPlay() {
            /* Triggers a speaker node randomly following the specified distribution */

            var chosen_id = void 0;
            // If speaker node is of uniform distribution
            if (this._speakerLayerProbabilityDistribution.length == 0) {
                chosen_id = Math.floor(Math.random() * this.graphData.clusterMat[0].length);
            } else {
                chosen_id = this._chooseRandomAdjVertexFromSpeakerLayer();
            }
            this._triggerSpeakerNode(chosen_id);
        }
    }, {
        key: "_triggerSpeakerNode",
        value: function _triggerSpeakerNode(id) {
            var _this5 = this;

            /* triggers a speaker node by id, traverse down and draw the visited path. */

            var speakerLayerLength = this.graphData.clusterMat[0].length;

            // Only allow the node to be clicked if it is in the speaker layer
            if (id < speakerLayerLength) {
                var clickedVertexId = parseInt(id, 10);
                this._traverseGraph(clickedVertexId, this.graphData.data);
                log("visited path = [" + this._directedPath + "]");
                this._drawGraph(this.graphData.data);
                this._drawVisitedPath(this.graphData.data);

                // testing
                $(this._divID + ' .path strong').text(this._directedPath);
            } else {
                // Else clear the path
                this._clearVisitedPath();
            }

            // Do not allow user to click
            this._canClick = false;
            setTimeout(function() {
                return _this5._canClick = true;
            }, this.config.edge.timeInterval * (this._directedPath.length - 1));
        }
    }, {
        key: "redraw",
        value: function redraw() {
            /* Use this to redraw the graph after reset edge weights */
            this._createEdgesInGraphData(this.graphData.data);
            this._drawGraph(this.graphData.data);

            return this;
        }
    }, {
        key: "init",
        value: function init() {
            /* Used to initialize and display the graph  after the set up is done*/

            this._dataScreening(this.graphData.data);

            this.setUniformEdgeWeights();

            this._createEdgesInGraphData(this.graphData.data);

            if (this.config.autoPlayable) this._createPlayButton();

            if (this.config.cyclingSpeedControllable) this._createCyclingSpeedControlButton();

            if (this.config.background.grid) this._drawGrid();

            this._drawGraph(this.graphData.data);

            return this;
        }
    }, {
        key: "getWeightedAdjacencyMatrix",
        value: function getWeightedAdjacencyMatrix() {
            return this._weightedAdjMat;
        }
    }, {
        key: "setEdgeWeights",
        value: function setEdgeWeights(id, weights) {
            /* Set adjacent vertex for vertex with id 
                return this pgm to allow setEdgeWeights to be stacked
            */

            if (id === undefined || weights === undefined) {
                throw new Error("graphicalModel.setEdgeWeights(id, adjVtx) params are not defined.");
            }

            this.graphData.data[id].edgeWeights = weights;
            this.redraw();

            return this;
        }

        //    this.setLabel = function (id, label) {
        //        /* Set label for vertex */
        //        this.graphData.data[id].label = label;
        //    };

        //    this.getGraphData = function () {
        //        /* Returns the graphData as  JSON object */
        //        let jsonGraphData = Utils.cloneDR(this.graphData);
        //
        //        console.log(jsonGraphData);
        //
        //        // Delete all the edge circular structures in the object
        //        for (let i = 0; i < jsonGraphData.data.length; i++) {
        //            delete(jsonGraphData.data[i].edges);
        //        }
        //
        //        return JSON.stringify(jsonGraphData);
        //    };

        // Used by createCluster()

    }, {
        key: "_changeNodeRadius",
        value: function _changeNodeRadius(baseRadius) {
            /* 
            Change the speaker layer ndoe radius based on the probability distribution
            probabilityDistribution is the array of probability given to each node in the speaker layer
            set probabilityDistribution=[] for uniform distribution
            */

            var normalizeBaseRadiusMultiplier = 0.4; // increase base radius size
            var normalizeExtraRadiusBasedOnDistributionMultiplier = 0.7; // increase extra radius size

            for (var i = 0; i < this._speakerLayerProbabilityDistribution.length; i++) {
                // Normalize the radius
                var normalizationFactor = 1.0 / this._speakerLayerProbabilityDistribution.length / normalizeExtraRadiusBasedOnDistributionMultiplier;
                this.graphData.data[i].r = baseRadius * normalizeBaseRadiusMultiplier + this.graphData.data[i].r * (this._speakerLayerProbabilityDistribution[i] * 1.0) / normalizationFactor;
            }
        }
    }, {
        key: "createCluster",
        value: function createCluster(cMat, probabilityDistribution, changeNodeRadiusBasedOnDistribution) {
            /* 
            Used to create a clusters of nodes (Graphdata) based on the cMat(cluster matrix).
            Also set the speaker layer probabilility distribution and have the option to
            chagne the spekaer nodes radius based on probability
            
            cMat is the cluster matrix. Ex of cluster mat [layer1_label_array, layer2_label_array, layer3_label_array] 
            probabilityDistribution is the array of probability given to each node in the speaker layer
            set probabilityDistribution=[] for uniform distribution
            changeNodeRadiusBasedOnDistribution is the boolean that governs whether nodes radius are affected by its distribution
            */

            // Error checking
            if (probabilityDistribution.length != 0) {
                if (cMat[0].length != probabilityDistribution.length) {
                    throw new Error("graphicalModel.createCluster(): the number of the nodes in the first layer in cMat does not match the length of the probabilityDistribution array");
                }
                var tempDistTotal = 0;
                for (var i = 0; i < probabilityDistribution.length; i++) {
                    tempDistTotal += probabilityDistribution[i];
                }
                if (tempDistTotal != 1.0) {
                    throw new Error("graphicalModel.createCluster(): the probability of each node in the speaker layer does not add up to 1.0 in probabilityDistribution array");
                }
            }

            this._speakerLayerProbabilityDistribution = probabilityDistribution;

            this.cMatDim = []; //cMatDim is the dimension of the matrix, ex: [3,3,3]

            // Populate cMatDim
            for (var _i3 = 0; _i3 < cMat.length; _i3++) {
                this.cMatDim[_i3] = cMat[_i3].length;
            }

            var offsetPosX = this.config.transform.width / (this.cMatDim.length + 1); // get the x offset for first node
            var minPosY = this.config.transform.height / (Array.max(this.cMatDim) + 1); // get the y offset for the layer with the most amount of nodes

            // Data properties: id, x, y, r
            var data = [];
            var id = 0;
            var x = void 0;
            var y = void 0;
            var r = Array.min([offsetPosX, minPosY]) * this.config.vertex.radius;

            this.config.vertex.radius = r;

            for (var _i4 = 0; _i4 < this.cMatDim.length; _i4++) {
                // Reset offset Y coordinate for each layer
                var offSetPosY = this.config.transform.height / (this.cMatDim[_i4] + 1);
                for (var j = 0; j < this.cMatDim[_i4]; j++) {
                    x = offsetPosX * (_i4 + 1);
                    y = offSetPosY * (j + 1);
                    data.push({
                        id: id,
                        x: x,
                        y: y,
                        r: r
                    });
                    id++;
                }
            }

            // Label each vertex based on cMat labels
            var id_temp = 0;
            for (var _i5 = 0; _i5 < cMat.length; _i5++) {
                for (var _j = 0; _j < cMat[_i5].length; _j++) {
                    data[id_temp++].label = cMat[_i5][_j];
                }
            } // Update the this.config edge width and baseWidth
            this.config.edge.width = r * this.config.edge.width;
            this.config.edge.baseWidth = r * this.config.edge.baseWidth;

            // Create the graphData member variable in _pgm
            this.graphData = {
                clusterMat: cMat,
                data: data
            };

            // Change speaker node radius based on distribution
            if (changeNodeRadiusBasedOnDistribution && probabilityDistribution.length > 0) this._changeNodeRadius(r);

            return this;
        }
    }, {
        key: "getGraphData",
        value: function getGraphData() {
            return this.graphData;
        }
    }, {
        key: "getVertexId",
        value: function getVertexId(vertexCoordinate) {
            // get vertex id by coordinate
            // vertexCoordinate is a coordiante pair = [layer index, vertex index at that layer]

            var layerIdx = vertexCoordinate[0];
            var vertexIdx = vertexCoordinate[1];

            if (layerIdx >= this.cMatDim.length || vertexIdx >= this.cMatDim[layerIdx]) throw new Error("graphicalModel.getVertexId(): invalid vertex coordinate input, the vertex being accessed does not exist in the graph. Your input vertex coordinate is [" + vertexCoordinate + "], but the dimention of the cluster matrix is [" + this.cMatDim + "].");

            var id_temp = 0;
            for (var i = 0; i < layerIdx; i++) {
                id_temp += this.cMatDim[i];
            }
            id_temp += vertexIdx;

            return id_temp;
        }

        // Set the graph edge weights to be uniform

    }, {
        key: "setUniformEdgeWeights",
        value: function setUniformEdgeWeights() {
            for (var layerIdx = 0; layerIdx < this.cMatDim.length - 1; layerIdx++) {
                for (var vertexIdx = 0; vertexIdx < this.cMatDim[layerIdx]; vertexIdx++) {
                    var vertexID = this.getVertexId([layerIdx, vertexIdx]);
                    var numOfNodesNextLayer = this.cMatDim[layerIdx + 1];
                    var edgeWeights = [];
                    for (var i = 0; i < numOfNodesNextLayer; i++) {
                        edgeWeights[i] = {
                            id: this.getVertexId([layerIdx + 1, i]),
                            weight: 1.0 / numOfNodesNextLayer
                        };
                    }
                    this.setEdgeWeights(vertexID, edgeWeights);
                }
            }
        }

        /*=========== Graphical Model Autoplay ===========*/

    }, {
        key: "resetChart",
        value: function resetChart() {
            /* reset the _weightedAdjMat */
            this._weightedAdjMat.resetMatrixWeight();
            this._weightedAdjMat.redrawMatrix();
        }
    }, {
        key: "_startAutoPlay",
        value: function _startAutoPlay() {
            /* called by the play button to start autoplay */
            this._canClick = false;
            if (this._weightedAdjMat) this.resetChart();
            this.config.autoPlay.on = true;
            this._triggerSpeakerNodeAutoPlay();
        }
    }, {
        key: "_stopAutoPlay",
        value: function _stopAutoPlay() {
            /* called by the stop button to stop autoplay */
            this._canClick = true;
            this.config.autoPlay.on = false;

            this._clearVisitedPath();

            if (this._weightedAdjMat) {
                this._weightedAdjMat.resetMatrixWeight();
                this._weightedAdjMat.resetMatrixColorWeight();
                // this._weightedAdjMat.redrawMatrix();
            }
        }

        /*======== Binding Adjacency Matrix To The Graphical Model =======*/

    }, {
        key: "_updateChart",
        value: function _updateChart() {
            /* Used in _drawVisitedPath() to update the adjacency matrix _weightedAdjMat */
            var _rowIdx = this._directedPath[0];
            var _colIdx = this._directedPath[this._directedPath.length - 1];
            if (_rowIdx < 0 || _colIdx < 0) return;

            var _rowLabel = this.graphData.data[_rowIdx].label;
            var _colLabel = this.graphData.data[_colIdx].label;
            var cellToUpdate = [_rowLabel, _colLabel];
            log("Update Cell: [" + cellToUpdate + "]");
            this._weightedAdjMat.increaseCellWeight(cellToUpdate, 1);
            this._weightedAdjMat.increaseCellColor(cellToUpdate, 1);
            this._weightedAdjMat.redrawMatrix();
        }
    }, {
        key: "createAdjacencyMatrix",
        value: function createAdjacencyMatrix(chartConfig) {
            /* Create a _weightedAdjMat and bind to the graphic model */

            this.chartConfig = chartConfig;

            if (this.graphData.clusterMat.length < 2) {
                throw new Error("graphicalModel.createAdjacencyMatrix(): Can not create adjacency matrix for graphical model with layer number less than 2");
                return;
            }

            var _rowLabel = this.graphData.clusterMat[0];
            var _colLabel = this.graphData.clusterMat[this.graphData.clusterMat.length - 1];
            this._weightedAdjMat = new WeightedAdjacencyMatrix(this._divID, chartConfig);
            this._weightedAdjMat.createMatrix(_rowLabel, _colLabel);

            return this;
        }
    }]);

    return GraphicalModel;
}();

/*=============================================================*/
/*=================== ListenerObserverPGM =====================*/
/*=============================================================*/

"use strict";

// A wrapper that combines both listenerBeliefPGM and ListenerPGM

var ListenerObserverPGM = function() {
    function ListenerObserverPGM(divID, listenerBeliefConfig, listenerConfig, adjMatConfig, cMat, speakerLayerProbabilityDistribution, changeNodeRadiusBasedOnDistribution) {
        _classCallCheck(this, ListenerObserverPGM);

        this._divID = divID;
        // parepare two id html elemnts for both listener and listener's belief pgms
        var listenerBeliefID = divID + "ListenerBeliefPGM";
        var listenerID = divID + "ListenerPGM";

        var $listenerBelief = $("<div>", {
            id: listenerBeliefID.substring(1)
        });
        var $listener = $("<div>", {
            id: listenerID.substring(1)
        });

        $(this._divID).append($listenerBelief);
        $(this._divID).append($listener);

        // Creating ListenerBeliefPGM first
        this.listenerBelif = new ListenerBeliefPGM(listenerBeliefConfig, listenerBeliefID).createCluster(cMat, speakerLayerProbabilityDistribution, changeNodeRadiusBasedOnDistribution).createAdjacencyMatrix(adjMatConfig).init();

        // Add image
        // this.listenerBelif.svg.append("svg:image")
        //     .attr('x', -9)
        //     .attr('y', -12)
        //     .attr('width', 200)
        //     .attr('height', 200)
        //     .attr("xlink:href", "img/1.png");

        // Then create ListenerPGM first based on the configuration
        // and bind the data to the graph for rendering
        var listenerClusterMatrix = [cMat[1], cMat[0]]; // mirror image of the belisef graph
        this.listener = new ListenerPGM(listenerConfig, listenerID).createCluster(listenerClusterMatrix, [], true).init();

        this.listener.bindToListenerBeliefPGM(this.listenerBelif);
    }

    _createClass(ListenerObserverPGM, [{
        key: "setEdgeWeights",
        value: function setEdgeWeights(vertexId, adjacentEdgeWeights) {
            this.listenerBelif.setEdgeWeights(vertexId, adjacentEdgeWeights);
            this.listener.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();
            return this;
        }
    }]);

    return ListenerObserverPGM;
}();

/* 
ListenerBeliefPGM is composed of ListenerPGM
*/


var ListenerBeliefPGM = function(_GraphicalModel) {
    _inherits(ListenerBeliefPGM, _GraphicalModel);

    function ListenerBeliefPGM(graphConfiguration, divID) {
        _classCallCheck(this, ListenerBeliefPGM);

        // Creates the dialgue box here

        var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(ListenerBeliefPGM).call(this, graphConfiguration, divID));

        _this6._createDialogueBox();
        return _this6;
    }

    _createClass(ListenerBeliefPGM, [{
        key: "_createDialogueBox",
        value: function _createDialogueBox() {
            /* This method creates the dialogue box for listener's belief to achieve thought bubble effect.
            The dialogue box is consisited of resized background rect from the listener's belief PGM and 
            a small upsidedown triangle, which is used to give the feeling of a dialgoue bubble */

            var rectX = this.config.transform.width / 4,
                rectY = this.config.transform.height * 2 / 15,
                rectWidth = this.config.transform.width / 2,
                rectHeight = this.config.transform.height * 3 / 4,
                rectCornorRadius = this.config.transform.width / 15;
            this.rect.attr("class", "background").attr("x", rectX).attr("y", rectY).attr("rx", rectCornorRadius).attr("ry", rectCornorRadius).attr("width", rectWidth).attr("height", rectHeight).style("fill", this.config.background.color).style("pointer-events", "all").on("click", function(d) {
                pgm._backgroundOnClick();
            });

            var offSet = -1,
                trianglePoint1 = [rectX + rectWidth / 3, rectY + rectHeight + offSet],
                trianglePoint2 = [rectX + rectWidth / 2, this.config.transform.height],
                trianglePoint3 = [rectX + rectWidth * 2 / 3, rectY + rectHeight + offSet];
            var trianglePath = trianglePoint1[0] + "," + trianglePoint1[1] + ", " + trianglePoint2[0] + "," + trianglePoint2[1] + ", " + trianglePoint3[0] + "," + trianglePoint3[1];
            this.svg.append("polygon") // attach a polygon
            .style("fill", this.config.background.color).attr("points", trianglePath);
        }
    }, {
        key: "_calculateWeights",
        value: function _calculateWeights() {
            /*
                returns the normalized weights in a 1D array in the form of Wij, ex, [W_sub(1,1), W_sub(1,2), W_sub(2,1), W_sub(2,2)]
            */
            var weight = [];

            var firstLayerLength = this.graphData.clusterMat[0].length;
            var lastLayerLength = this.graphData.clusterMat[this.graphData.clusterMat.length - 1].length;
            // Calculate the new edge weights based on adj matrix
            for (var i = 0; i < firstLayerLength; i++) {
                for (var j = 0; j < lastLayerLength; j++) {
                    var M_ij = this.getWeightedAdjacencyMatrix().getCellWeight([i, j]);
                    var Mij_summation_over_j = 0;
                    for (var sigma_sub_j = 0; sigma_sub_j <= j; sigma_sub_j++) {
                        Mij_summation_over_j += this.getWeightedAdjacencyMatrix().getCellWeight([i, sigma_sub_j]);
                    }
                    // log([M_ij, Mij_summation_over_j])
                    var W_ij = M_ij === 0 ? 0 : M_ij / Mij_summation_over_j;
                    weight.push(W_ij);
                }
            }

            log("Weight = " + weight);

            // Noralize the weights so that all node's edge weights sum up to 1

            var vertexWeightSumTemp = []; // each element is the weight sum for a vertex
            var weightIdx = 1;
            var tempWeightSumForVertex = 0;
            for (var _i6 = 0; _i6 < weight.length; _i6++) {
                tempWeightSumForVertex += weight[_i6];
                if (weightIdx % firstLayerLength == 0) {
                    // push vertex sum "firstLayerLength" many times so its easier to normalize weight
                    for (var _j2 = 0; _j2 < firstLayerLength; _j2++) {
                        vertexWeightSumTemp.push(tempWeightSumForVertex);
                    }
                    tempWeightSumForVertex = 0;
                }
                weightIdx++;
            }

            log("vertexWeightSumTemp = " + vertexWeightSumTemp);

            // Normalize
            var normalizedWeight = [];
            for (var _i7 = 0; _i7 < weight.length; _i7++) {
                normalizedWeight[_i7] = vertexWeightSumTemp[_i7] === 0 ? 0 : weight[_i7] / vertexWeightSumTemp[_i7];
            }

            log("normalized weight = " + normalizedWeight);

            return normalizedWeight;
        }
    }, {
        key: "_cyclingSpeedControlButtonOnClick",
        value: function _cyclingSpeedControlButtonOnClick(ui) {
            _get(Object.getPrototypeOf(ListenerBeliefPGM.prototype), "_cyclingSpeedControlButtonOnClick", this).call(this, ui);
            // updating listenerPGM's speed on button click as well
            this.listenerPGM.config.edge.timeInterval = ui.value;
            this.listenerPGM.config.autoPlay.timeIntervalBetweenCycle = ui.value;
        }

        /*@Override*/

    }, {
        key: "_updateChart",
        value: function _updateChart() {
            // After updating the chart updating the weight in ListenerPGM as well
            _get(Object.getPrototypeOf(ListenerBeliefPGM.prototype), "_updateChart", this).call(this);

            var updatedWeights = this._calculateWeights();
            this.listenerPGM.updateWeight(updatedWeights);
            this.listenerPGM.redraw();
        }

        /*@Override*/
        // _backgroundOnClickToResetAdjMatrix() {
        //     // overrie original function so when background is clicked the matrix won't reset
        //     return false;
        // }
        // _backgroundOnClick() {}

        /*@Override*/

    }, {
        key: "_stopAutoPlay",
        value: function _stopAutoPlay() {
            _get(Object.getPrototypeOf(ListenerBeliefPGM.prototype), "_stopAutoPlay", this).call(this);
            // When stop button is clicked, reset the listenerPGM edgeweights as well
            // this.listenerPGM.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();
            // this.listenerPGM.redraw();
        }

        /*@Override*/

    }, {
        key: "_startAutoPlay",
        value: function _startAutoPlay() {
            /* When stop button is clicked, reset the listenerPGM edgeweights as well */

            // Stop listenerPGM autoplay before calling super._startPlay() so that _clearVisitedPath() method won't destroy both listenerPGM's autoPlay and this graph's autoPlay
            if (this.listenerPGM.config.autoPlay.on) {
                this.listenerPGM._stopAutoPlay();
            }

            _get(Object.getPrototypeOf(ListenerBeliefPGM.prototype), "_startAutoPlay", this).call(this);

            // reset the listenerPGM edge weights
            this.listenerPGM.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();
            this.listenerPGM.redraw();
        }

        /* @Override */

    }, {
        key: "createCluster",
        value: function createCluster(cMat, probabilityDistribution, changeNodeRadiusBasedOnDistribution) {

            this.listenerClusterMatrix = [cMat[1], cMat[0]]; // mirror image of the belisef graph
            this.listenerBeliefClusterMatrix = cMat;

            if (cMat.length != 2) throw new Error("ListenerBeliefPGM.createCluster(): invalid cMat length. This graph only supports two layer graphs.");
            _get(Object.getPrototypeOf(ListenerBeliefPGM.prototype), "createCluster", this).call(this, this.listenerBeliefClusterMatrix, probabilityDistribution, changeNodeRadiusBasedOnDistribution);
            return this;
        }
    }, {
        key: "bindToListenerPGM",
        value: function bindToListenerPGM(listener) {
            // Used to bind listenerPGM to listenerBeliefPGM
            this.listenerPGM = listener;
            return this;
        }
    }]);

    return ListenerBeliefPGM;
}(GraphicalModel);

var ListenerPGM = function(_GraphicalModel2) {
    _inherits(ListenerPGM, _GraphicalModel2);

    function ListenerPGM(graphConfiguration, divID) {
        _classCallCheck(this, ListenerPGM);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ListenerPGM).call(this, graphConfiguration, divID));
    }

    /*@Override*/


    _createClass(ListenerPGM, [{
        key: "_updateChart",
        value: function _updateChart() {}

        /*@Override*/

    }, {
        key: "_backgroundOnClick",
        value: function _backgroundOnClick() {
            // Prevent adjMatrix gets reset when click on background
            if (this._canClick && !this.listenerBeliefPGM.config.autoPlay.on) {
                _get(Object.getPrototypeOf(ListenerPGM.prototype), "_backgroundOnClick", this).call(this);
            }
        }
    }, {
        key: "resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights",
        value: function resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights() {
            // Set listenerPGM to be listenerBeliefPGM's mirror
            var weights = [];
            for (var i = 0; i < this.cMatDim[0]; i++) {
                for (var vertexIdx = 0; vertexIdx < this.listenerBeliefPGM.cMatDim[0]; vertexIdx++) {
                    var listenerEdgeWeights = this.listenerBeliefPGM.getGraphData().data[vertexIdx].edgeWeights;
                    weights.push(listenerEdgeWeights[i].weight);
                }
            }
            this.updateWeight(weights);
        }
    }, {
        key: "bindToListenerBeliefPGM",
        value: function bindToListenerBeliefPGM(belief) {
            // This binds the listener and the listener's belief to each other and set listener's weight.
            belief.bindToListenerPGM(this);
            this.listenerBeliefPGM = belief;

            var listenerPGM = this;
            // Redefine onClick when bind to listenerBeliefPGM to prevent adjMatrix gets reset when click on background
            this.onClick = d3.behavior.drag().origin(function(d) {
                return d;
            }).on("dragstart", function(d) {
                // Check if the clicked node is in the first layer
                // which are the num of nodes in first layer of clusterMat
                // Only allow user to click the node if autoplay is off
                if (!listenerPGM.listenerBeliefPGM.config.autoPlay.on) {
                    d3.event.sourceEvent.stopPropagation();
                    d3.select(this).classed("dragging", true);

                    // Option 1: Only draw visited path once
                    // listenerPGM._triggerSpeakerNode(this.id);

                    // Option 2: AutoPlay when speaker node is clicked
                    var speakerLayerLength = listenerPGM.graphData.clusterMat[0].length;
                    if (listenerPGM.config.autoPlay.on) {
                        listenerPGM._stopAutoPlay();
                    } else {
                        listenerPGM._startAutoPlay();
                    }
                }
            });
            this.resetEdgeWeightsToBeListenerBeliefPGMEdgeWeights();

            return this;
        }
    }, {
        key: "updateWeight",
        value: function updateWeight(weight) {
            // Used by listenerBelief to update the pgm weigth
            // takes in the weights as an 1D array and set the weights
            var weightIdx = 0;
            for (var vertexIdx = 0; vertexIdx < this.cMatDim[0]; vertexIdx++) {
                var edgeWeights = [];
                for (var i = 0; i < this.cMatDim[1]; i++) {
                    edgeWeights[i] = {
                        id: this.getVertexId([1, i]),
                        weight: weight[weightIdx]
                    };
                    weightIdx++;
                }
                this.setEdgeWeights(vertexIdx, edgeWeights);
            }
        }
    }]);

    return ListenerPGM;
}(GraphicalModel);

'use strict';

/**
 * Created by Alex Chenxing Ouyang
 * This is used to obtain the default configurations for PGMs
 */

var Configuration = function() {
    function Configuration() {
        _classCallCheck(this, Configuration);

        /**
         * @memberof WeightedAdjMat
         * @type {Object}
         * @property {Object} transform - The transform property can be used to position and scale the WeightedAdjMat object
         * @property {Object} matrix - The matix property can be used to position, scale and color the matrix
         * @property {Object} label - The label property can be used to color and scale the matrix labels
         * @property {Object} text - The text property can be used to color and scale the matrix cell weight
         * @property {Object} background - The background property can be used to change the color of the background
         */

        // Handles the configuration of listener's belief
        this._listenerBeliefConfig = {
            transform: {
                x: 0,
                y: 0,
                width: window.innerWidth * 2 / 3 - 20,
                height: window.innerWidth / 2.5
            },
            vertex: {
                radius: .35,
                defaultStyle: {
                    backgroundColor: "#52bf90",
                    outlineColor: "#317256"
                },
                visited: {
                    visitedColor: "#1d4433",
                    outlineColor: "#1d4433"
                }
            },
            edge: {
                baseWidth: 0, // base width offset = baseWidth * circle radius
                width: 1, // edge width = width * circle radius
                defaultColor: "#74cba6",
                visitedColor: "#1d4433",
                timeInterval: 400 // timeInterval is in millisecond
            },
            text: {
                color: "white",
                size: 0.5, // text size = size * circle radius
                anchor: "middle",
                alignment: "middle"

            },
            background: {
                grid: false,
                color: "#ccecde"
            },
            autoPlay: {
                on: false,
                button: {
                    dim: 1,
                    color: "#52bf90"
                },
                timeIntervalBetweenCycle: 400
            },
            autoPlayable: true, // If autoPlayable, creates the autoplay button
            cyclingSpeedControllable: true, // if cyclingSpeedControllable, create speed button
            zoomable: false
        };

        // Handles the configuration of listener
        this._listenerConfig = {
            transform: {
                x: 0,
                y: 0,
                width: window.innerWidth * 2 / 3 - 20,
                height: window.innerWidth / 3
            },
            vertex: {
                radius: 0.35,
                defaultColor: "#52bf90",
                visitedColor: "#1d4433",
                outlineColor: "#317256"
            },
            edge: {
                baseWidth: 0, // base width offset = baseWidth * circle radius
                width: 1, // edge width = width * circle radius
                defaultColor: "#b6ddcc",
                visitedColor: "#1d4433",
                timeInterval: 400 // timeInterval is in millisecond
            },
            text: {
                color: "white",
                size: 0.5, // text size = size * circle radius
                anchor: "middle",
                alignment: "middle"

            },
            background: {
                grid: false,
                color: "rgba(255, 255, 255, 0)"
            },
            autoPlay: {
                on: false,
                button: {
                    dim: 1,
                    color: "#74cba6"
                },
                timeIntervalBetweenCycle: 400
            },
            autoPlayable: false, // If autoPlayable, creates the autoplay button
            cyclingSpeedControllable: false, // if cyclingSpeedControllable, create speed button
            zoomable: false
        };

        // Adjacency matrix configuration
        this._adjacencyMatrixConfig = {
            transform: {
                x: 0,
                y: 0,
                width: window.innerWidth / 3,
                height: window.innerWidth / 3
            },
            matrix: {
                x: 0.3,
                y: 0.3,
                cellDim: 0.5,
                cellSpacing: 1,
                color: "#63c59b"
            },
            label: {
                color: "#52bf90",
                size: 0.5, // text size = size * circle radius
                anchor: "middle",
                alignment: "middle"
            },
            weight: {
                color: "white",
                size: 0.6, // weight text size = size * circle radius
                anchor: "middle",
                alignment: "middle"
            },
            background: {
                color: "rgba(255, 255, 255, 0)"
            }
        };

        // This is the config for regular pgm
        this._pgmConfig = {
            transform: {
                x: 0,
                y: 0,
                width: window.innerWidth * 2 / 3 - 20,
                height: window.innerWidth / 3
            },
            vertex: {
                radius: 0.35,
                defaultStyle: {
                    backgroundColor: "#52bf90",
                    outlineColor: "#317256"
                },
                visited: {
                    visitedColor: "#1d4433",
                    outlineColor: "#1d4433"
                }
            },
            edge: {
                baseWidth: 0, // base width offset = baseWidth * circle radius
                width: 1, // edge width = width * circle radius
                defaultColor: "#b6ddcc",
                visitedColor: "#1d4433",
                timeInterval: 400 // timeInterval is in millisecond
            },
            text: {
                color: "white",
                size: 0.5, // text size = size * circle radius
                anchor: "middle",
                alignment: "middle"

            },
            background: {
                grid: true,
                color: "#ecf6f2"
            },
            autoPlay: {
                on: false,
                button: {
                    dim: 1,
                    color: "#52bf90"
                },
                timeIntervalBetweenCycle: 400
            },
            autoPlayable: true, // If autoPlayable, creates the autoplay button
            cyclingSpeedControllable: true, // if cyclingSpeedControllable, create speed button
            zoomable: false
        };
    }

    _createClass(Configuration, [{
        key: "getListenerBeliefConfig",
        value: function getListenerBeliefConfig() {
            return Utils.cloneDR(this._listenerBeliefConfig);
        }
    }, {
        key: "getListenerConfig",
        value: function getListenerConfig() {
            return Utils.cloneDR(this._listenerConfig);
        }
    }, {
        key: "getAdjacencyMatrixConfig",
        value: function getAdjacencyMatrixConfig() {
            return Utils.cloneDR(this._adjacencyMatrixConfig);
        }
    }, {
        key: "getPgmConfig",
        value: function getPgmConfig() {
            return Utils.cloneDR(this._pgmConfig);
        }
    }]);

    return Configuration;
}();

var Config = new Configuration();

/*=============== Utilities ==================*/

// Used to replace console.log,  EX: log('hello'); // hello
var log = function log(mesg) {
    return console.log(mesg);
};

// Implement max and min function for array
Array.max = function(array) {
    return Math.max.apply(Math, array);
};
Array.min = function(array) {
    return Math.min.apply(Math, array);
};

var Utils = {};

(function() {
    "use strict";

    Utils.cloneDR = function cloneDR(o) {
        /* Clone an object deeply and recursively */

        var gdcc = "__getDeepCircularCopy__";
        if (o !== Object(o)) {
            return o; // primitive value
        }

        var set = gdcc in o,
        cache = o[gdcc],
        result = void 0;
        if (set && typeof cache == "function") {
            return cache();
        }
        // else
        o[gdcc] = function() {
            return result;
        };
        // overwrite
        if (o instanceof Array) {
            result = [];
            for (var i = 0; i < o.length; i++) {
                result[i] = cloneDR(o[i]);
            }
        } else {
            result = {};
            for (var prop in o) {
                if (prop != gdcc) {
                    result[prop] = cloneDR(o[prop]);
                } else if (set) {
                    result[prop] = cloneDR(cache);
                }
            }
        }
        if (set) {
            o[gdcc] = cache; // reset
        } else {
            delete o[gdcc]; // unset again
        }
        return result;
    };

    Utils.isObjLiteral = function isObjLiteral(_obj) {
        /* verify if an object is an object literal */

        var _test = _obj;
        return (typeof _obj === "undefined" ? "undefined" : _typeof(_obj)) !== 'object' || _obj === null ? false : function() {
            while (!false) {
                if (Object.getPrototypeOf(_test = Object.getPrototypeOf(_test)) === null) {
                    break;
                }
            }
            return Object.getPrototypeOf(_obj) === _test;
        }();
    };

    /**
     * Darkens or lightens hex color value
     * percentage ranges form -100(dark) to +100(light)
     */
    Utils.shadeColor = function Utils(colorHex, percent) {

        var R = parseInt(colorHex.substring(1, 3), 16);
        var G = parseInt(colorHex.substring(3, 5), 16);
        var B = parseInt(colorHex.substring(5, 7), 16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = R < 255 ? R : 255;
        G = G < 255 ? G : 255;
        B = B < 255 ? B : 255;

        var RR = R.toString(16).length === 1 ? "0" + R.toString(16) : R.toString(16);
        var GG = G.toString(16).length === 1 ? "0" + G.toString(16) : G.toString(16);
        var BB = B.toString(16).length === 1 ? "0" + B.toString(16) : B.toString(16);

        return "#" + RR + GG + BB;
    };
})();

/*=============== Weighted Adjacency Matrix Graph ====================*/

"use strict";

var WeightedAdjacencyMatrix = function() {

    /**
     * Creates a color coded adjacency matrix contained in a WeightedAdjMat object
     * @class
     * @constructor
     * @param {String} divID - the id of the div that contains the graph, e.g "#id"
     * @param {Object} matrixConfiguration - The configurations of the adjacency matrix
     */

    function WeightedAdjacencyMatrix(divID, matrixConfiguration) {
        _classCallCheck(this, WeightedAdjacencyMatrix);

        this.config = matrixConfiguration;

        this._divID = divID;

        this._adjMatData = []; // Contains the matrix cell data and cell label data

        this._rowLabel = []; // Contains the row labels in string. e.g["square", "circle"]

        this._colLabel = []; // Contains the column labels in string. e.g["square", "circle"]

        this._svg = d3.select(this._divID).append('svg').attr("class", "weightedAdjMat").attr('width', this.config.transform.width).attr('height', this.config.transform.height).append('g').attr("transform", "translate(" + this.config.transform.x + "," + this.config.transform.y + ")");

        // Create the background wrapper for color theme
        this._svg.append("rect").attr("class", "background").attr("width", this.config.transform.width).attr("height", this.config.transform.height).style("fill", this.config.background.color);
    }

    /**
     * Darkens or lightens hex color value
     * @function _shadeColor
     * @param {String} colorHex - a hex color string. ie. "#63c59b"
     * @param {Number} percentage - shading ranges form -100(dark) to +100(light)
     */


    _createClass(WeightedAdjacencyMatrix, [{
        key: "_shadeColor",
        value: function _shadeColor(colorHex, percent) {

            var R = parseInt(colorHex.substring(1, 3), 16);
            var G = parseInt(colorHex.substring(3, 5), 16);
            var B = parseInt(colorHex.substring(5, 7), 16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = R < 255 ? R : 255;
            G = G < 255 ? G : 255;
            B = B < 255 ? B : 255;

            var RR = R.toString(16).length === 1 ? "0" + R.toString(16) : R.toString(16);
            var GG = G.toString(16).length === 1 ? "0" + G.toString(16) : G.toString(16);
            var BB = B.toString(16).length === 1 ? "0" + B.toString(16) : B.toString(16);

            return "#" + RR + GG + BB;
        }

        /** 
         * Draws the adjancy matrix based on the property of each cell
         * @function redrawMatrix
         */

    }, {
        key: "redrawMatrix",
        value: function redrawMatrix() {
            var _this8 = this;

            /* Draw the adjancy matrix */

            d3.selectAll(this._divID + " g .cell").remove();
            d3.selectAll(this._divID + " g .label").remove();

            // Each cell group holds
            var cell = this._svg.selectAll('g').data(this._adjMatData).enter().append("g").attr("class", "cell").attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });

            // Each rect is a matrix cell
            cell.append("rect").attr("transform", "translate(" + -this.config.matrix.cellDim / 2 + "," + -this.config.matrix.cellDim / 2 + ")").attr('width', this.config.matrix.cellDim).attr('height', this.config.matrix.cellDim).attr('fill', function(d) {
                // Add color to the cell matrix
                if (d.type === "cellData") {
                    return _this8._shadeColor(_this8.config.matrix.color, -d.colorWeight * 5);
                }
                if (d.type === "cellLabel") {
                    return _this8.config.background.color;
                }
            });

            // Add cell weight text
            cell.append("text").attr("font-size", this.config.matrix.cellDim * this.config.weight.size).attr("text-anchor", this.config.weight.anchor).attr("alignment-baseline", this.config.weight.alignment).attr("fill", this.config.weight.color).text(function(d) {
                if (d.type === "cellData") {
                    return d.weight;
                }
            });

            // Add cell label text
            cell.append("text").attr("font-size", this.config.matrix.cellDim * this.config.label.size).attr("text-anchor", this.config.label.anchor).attr("alignment-baseline", this.config.label.alignment).attr("fill", this.config.label.color).text(function(d) {
                if (d.type === "cellLabel") {
                    return d.label;
                }
            });
        }

        /** 
         * Creates an adjacency matrix based on the row and column labels
         * @function WeightedAdjMat.createMatrix
         * @param {Array} rowLab - labels that represent the row of the matrix
         * @param {Array} colLab - labels that represent the column of the matrix
         */

    }, {
        key: "createMatrix",
        value: function createMatrix(rowLab, colLab) {

            this._rowLabel = rowLab; // Update the labels
            this._colLabel = colLab; // Update the labels

            // Calculate the dimension of each block and other matrix config properties
            this.config.matrix.cellDim = this.config.matrix.cellDim * Array.min([this.config.transform.width, this.config.transform.height]) / Array.max([this._rowLabel.length, this._colLabel.length]);
            this.config.matrix.cellSpacing *= this.config.matrix.cellDim / 10;
            this.config.matrix.x *= this.config.transform.width;
            this.config.matrix.y *= this.config.transform.height;

            // Populate adjacency matrix data
            var id = 0;
            var x = void 0;
            var y = void 0;
            for (var i = 0; i < this._rowLabel.length; i++) {
                for (var j = 0; j < this._colLabel.length; j++) {
                    x = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (j + 1 / 2) + this.config.matrix.x;
                    y = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (i + 1 / 2) + this.config.matrix.y;
                    this._adjMatData.push({
                        type: "cellData",
                        id: id,
                        x: x,
                        y: y,
                        weight: 0,
                        colorWeight: 0
                    });
                    id++;
                }
            }

            // Add column labels to the adjacent matrix.
            for (var _i8 = 0; _i8 < this._colLabel.length; _i8++) {
                // Add column labels
                x = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (_i8 + 1 / 2) + this.config.matrix.x;
                y = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (-1 / 2) + this.config.matrix.y;
                this._adjMatData.push({
                    type: "cellLabel",
                    label: this._colLabel[_i8],
                    x: x,
                    y: y
                });
            }

            // Add row labels to the adjacent matrix.
            for (var _i9 = 0; _i9 < this._rowLabel.length; _i9++) {
                // Add row labels
                x = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (-1 / 2) + this.config.matrix.x;
                y = (this.config.matrix.cellDim + this.config.matrix.cellSpacing) * (_i9 + 1 / 2) + this.config.matrix.y;
                this._adjMatData.push({
                    type: "cellLabel",
                    label: this._rowLabel[_i9],
                    x: x,
                    y: y
                });
            }

            this.redrawMatrix();
        }

        /** 
         * Increases the matix cell weight by label pair.
         * @function WeightedAdjMat.increaseCellWeight
         * @param {Array} cell - the cell to increase weight is represented by a coordinate pair using labels, ie. cell = (rowLabel, colLabel)
         * @param {Integer} weight - used to increase the weight of the cell
         */

    }, {
        key: "increaseCellWeight",
        value: function increaseCellWeight(cell, weight) {
            var row = this._rowLabel.indexOf(cell[0]);
            var col = this._colLabel.indexOf(cell[1]);

            if (row < 0 || col < 0) throw new Error("updateMatrix(cell): the element updated does not exist in the adjacency matrix.");

            var elementIndex = row * this._colLabel.length + col;
            this._adjMatData[elementIndex].weight += weight;
        }

        /** 
         * Increases the matix cell color weight and darkens the color by label pair.
         * @function WeightedAdjMat.increaseCellColor
         * @param {Array} cell - the cell to increase weight is represented by a coordinate pair using labels, ie. cell = (rowLabel, colLabel)
         * @param {Integer} weight - used to increase the color weight of the cell
         */

    }, {
        key: "increaseCellColor",
        value: function increaseCellColor(cell, colorWeight) {
            var row = this._rowLabel.indexOf(cell[0]);
            var col = this._colLabel.indexOf(cell[1]);

            if (row < 0 || col < 0) throw new Error("updateMatrix(cell): the element updated does not exist in the adjacency matrix.");

            var elementIndex = row * this._colLabel.length + col;
            this._adjMatData[elementIndex].colorWeight += colorWeight;
        }

        /** 
         * Increases the matix column color weight and darkens the color
         * @function WeightedAdjMat.increaseColumnColor
         * @param {Array} colLabel - the label of the column to increase weight is represented by a label in string
         * @param {Integer} weight - used to increase the color weight of the cell
         */

    }, {
        key: "increaseColumnColor",
        value: function increaseColumnColor(colLabel, colorWeight) {
            var col = this._colLabel.indexOf(colLabel);

            if (col < 0) throw new Error("increaseColumnColor: the column updated does not exist in the adjacency matrix.");

            for (var row = 0; row < this._rowLabel.length; row++) {
                var elementIndex = row * this._colLabel.length + col;
                this._adjMatData[elementIndex].colorWeight += colorWeight;
            }
        }

        /** 
         * Reset the matix cell weight
         * @function WeightedAdjMat.resetMatrixWeight
         */

    }, {
        key: "resetMatrixWeight",
        value: function resetMatrixWeight() {
            /* Reset each matrix cell weight to 0 */
            for (var i = 0; i < this._adjMatData.length; i++) {
                if (this._adjMatData[i].type === "cellData") {
                    this._adjMatData[i].weight = 0;
                }
            }
        }

        /** 
         * Reset the matix cell color weight and updates color based on the weight
         * @function WeightedAdjMat.resetMatrixColorWeight
         */

    }, {
        key: "resetMatrixColorWeight",
        value: function resetMatrixColorWeight() {
            /* Reset each matrix cell weight to 0 */
            for (var i = 0; i < this._adjMatData.length; i++) {
                if (this._adjMatData[i].type === "cellData") {
                    this._adjMatData[i].colorWeight = 0;
                }
            }
        }

        /** 
         * Get the matix cell weight by cell pair = (i, j)
         * @function WeightedAdjMat.getCellWeight
         * @param {Array} cell - the cell to increase weight is represented by a coordinate pair, ie. cell = (i, j)
         * @return {Integer} cell weight
         */

    }, {
        key: "getCellWeight",
        value: function getCellWeight(cell) {
            var i = cell[0];
            var j = cell[1];

            if (i > this._colLabel.length || j > this._rowLabel.length || i < 0 || j < 0) throw new Error("getCellWeight(cell): the element to get does not exist in the adjacency matrix.");

            var elementIndex = i + j * this._colLabel.length;
            return this._adjMatData[elementIndex].weight;
        }
    }, {
        key: "getMatrix1D",
        value: function getMatrix1D() {
            // Returns the adjacency matrix as a 1D array
            var matrix1D = [];
            for (var i = 0; i < this._adjMatData.length; i++) {
                if (this._adjMatData[i].type == "cellData") {
                    matrix1D.push(this._adjMatData[i].weight);
                }
            }
            return matrix1D;
        }
    }, {
        key: "getMatrix2D",
        value: function getMatrix2D() {
            // Returns the adjacency matrix as a 2D array,
            // matrix = [col1, col2, col3];
            var matrix1D = this.getMatrix1D();
        }

        //    resetRowLabel(row) {
        //        this._rowLabel = row;
        //    }
        //
        //    resetColLabel(col) {
        //        this._colLabel = col;
        //    }

    }]);

    return WeightedAdjacencyMatrix;
}();